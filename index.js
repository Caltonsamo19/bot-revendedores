require('dotenv').config();
const { Client, LocalAuth } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs').promises;
const axios = require('axios'); // npm install axios

// === IMPORTAR A IA ===
const WhatsAppAI = require('./whatsapp_ai');

// === IMPORTAR SISTEMA DE PACOTES ===
const SistemaPacotes = require('./sistema_pacotes');

// === IMPORTAR SISTEMA DE COMPRAS ===
const SistemaCompras = require('./sistema_compras');

// === CONFIGURA√á√ÉO GOOGLE SHEETS - BOT RETALHO (SCRIPT PR√ìPRIO) ===
const GOOGLE_SHEETS_CONFIG = {
    scriptUrl: process.env.GOOGLE_SHEETS_SCRIPT_URL_RETALHO || 'https://script.google.com/macros/s/AKfycbyMilUC5bYKGXV95LR4MmyaRHzMf6WCmXeuztpN0tDpQ9_2qkgCxMipSVqYK_Q6twZG/exec',
    planilhaUrl: 'https://docs.google.com/spreadsheets/d/1vIv1Y0Hiu6NHEG37ubbFoa_vfbEe6sAb9I4JH-P38BQ/edit',
    planilhaId: '1vIv1Y0Hiu6NHEG37ubbFoa_vfbEe6sAb9I4JH-P38BQ',
    timeout: 30000,
    retryAttempts: 3,
    retryDelay: 2000
};

// === CONFIGURA√á√ÉO DE PAGAMENTOS (MESMA PLANILHA DO BOT ATACADO) ===
const PAGAMENTOS_CONFIG = {
    scriptUrl: 'https://script.google.com/macros/s/AKfycbzzifHGu1JXc2etzG3vqK5Jd3ihtULKezUTQQIDJNsr6tXx3CmVmKkOlsld0x1Feo0H/exec',
    timeout: 30000
};

console.log(`üìä Google Sheets configurado`);

// Fun√ß√£o helper para reply com fallback
async function safeReply(message, client, texto) {
    try {
        await message.reply(texto);
    } catch (error) {
        console.log('‚ö†Ô∏è Erro no reply, usando sendMessage como fallback:', error.message);
        try {
            await client.sendMessage(message.from, texto);
        } catch (fallbackError) {
            console.error('‚ùå Erro tamb√©m no sendMessage fallback:', fallbackError.message);
            throw fallbackError;
        }
    }
}

// Criar inst√¢ncia do cliente
const client = new Client({
    authStrategy: new LocalAuth({
        clientId: "bot_retalho_modificado" // Diferente do bot atacado
    }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox', 
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--disable-gpu',
            '--disable-extensions',
            '--no-default-browser-check',
            '--disable-default-apps',
            '--disable-translate',
            '--disable-sync'
        ],
        executablePath: undefined, // Use default Chrome
        timeout: 0, // Remove timeout
        ignoreDefaultArgs: ['--disable-extensions']
    }
});

// === INICIALIZAR A IA ===
require('dotenv').config();
const ia = new WhatsAppAI(process.env.OPENAI_API_KEY);

// === SISTEMA DE PACOTES (ser√° inicializado ap√≥s WhatsApp conectar) ===
let sistemaPacotes = null;
let sistemaCompras = null;

// Configura√ß√£o para encaminhamento
const ENCAMINHAMENTO_CONFIG = {
    grupoOrigem: '120363152151047451@g.us', // Phull Megas
    numeroDestino: '258861645968@c.us',
    intervaloSegundos: 2
};

// Fila de mensagens para encaminhar
let filaMensagens = [];
let processandoFila = false;

// === VARI√ÅVEIS PARA DADOS ===
let dadosParaTasker = [];

// === SISTEMA DE REFER√äNCIAS E B√îNUS ===
let codigosReferencia = {}; // codigo -> dados do dono
let referenciasClientes = {}; // cliente -> dados da referencia
let bonusSaldos = {}; // cliente -> saldo e historico
let pedidosSaque = {}; // referencia -> dados do pedido
let membrosEntrada = {}; // {grupoId: {memberId: dataEntrada}}

// Arquivos de persist√™ncia
const ARQUIVO_REFERENCIAS = './dados_referencias.json';
const ARQUIVO_BONUS = './dados_bonus.json';
const ARQUIVO_CODIGOS = './dados_codigos.json';
const ARQUIVO_SAQUES = './dados_saques.json';
const ARQUIVO_MEMBROS = './dados_membros_entrada.json';

// === FUN√á√ïES DO SISTEMA DE REFER√äNCIA ===

// Cache para controlar boas-vindas (evitar spam)
let cacheBoasVindas = {}; // {grupoId_participantId: timestamp}
let ultimosParticipantes = {}; // {grupoId: [participantIds]} - cache dos participantes

// Sistema autom√°tico de detec√ß√£o de novos membros
async function iniciarMonitoramentoMembros() {
    console.log('üïµÔ∏è Iniciando monitoramento autom√°tico de novos membros...');
    
    // Executar a cada 30 segundos
    setInterval(async () => {
        try {
            await verificarNovosMembros();
        } catch (error) {
            console.error('‚ùå Erro no monitoramento de membros:', error);
        }
    }, 30000); // 30 segundos
    
    // Primeira execu√ß√£o ap√≥s 10 segundos (para dar tempo do bot conectar)
    setTimeout(async () => {
        await verificarNovosMembros();
    }, 10000);
}

// Verificar novos membros em todos os grupos monitorados
async function verificarNovosMembros() {
    for (const grupoId of Object.keys(CONFIGURACAO_GRUPOS)) {
        try {
            await detectarNovosMembrosGrupo(grupoId);
        } catch (error) {
            // Silencioso para n√£o poluir logs
        }
    }
}

// Detectar novos membros em um grupo espec√≠fico
async function detectarNovosMembrosGrupo(grupoId) {
    try {
        const chat = await client.getChatById(grupoId);
        const participants = await chat.participants;
        const participantIds = participants.map(p => p.id._serialized);
        
        // Se √© a primeira vez que verificamos este grupo
        if (!ultimosParticipantes[grupoId]) {
            ultimosParticipantes[grupoId] = participantIds;
            return;
        }
        
        // Encontrar novos participantes
        const novosParticipantes = participantIds.filter(id => 
            !ultimosParticipantes[grupoId].includes(id)
        );
        
        // Processar novos membros
        for (const participantId of novosParticipantes) {
            await processarNovoMembro(grupoId, participantId);
        }
        
        // Atualizar cache
        ultimosParticipantes[grupoId] = participantIds;
        
    } catch (error) {
        // Silencioso - grupo pode n√£o existir ou bot n√£o ter acesso
    }
}

// Processar novo membro detectado
async function processarNovoMembro(grupoId, participantId) {
    try {
        const configGrupo = getConfiguracaoGrupo(grupoId);
        if (!configGrupo) return;
        
        const cacheKey = `${grupoId}_${participantId}`;
        const agora = Date.now();
        
        // Verificar se j√° enviamos boas-vindas recentemente (√∫ltimas 24h)
        if (cacheBoasVindas[cacheKey] && (agora - cacheBoasVindas[cacheKey]) < (24 * 60 * 60 * 1000)) {
            return;
        }
        
        console.log(`üëã Novo membro detectado`);
        
        // Registrar entrada do membro
        await registrarEntradaMembro(grupoId, participantId);
        
        // Marcar como processado
        cacheBoasVindas[cacheKey] = agora;
        
        // Enviar boas-vindas com delay aleat√≥rio
        setTimeout(async () => {
            try {
                await enviarBoasVindas(grupoId, participantId);
                console.log(`‚úÖ Boas-vindas enviadas`);
            } catch (error) {
                console.error(`‚ùå Erro ao enviar boas-vindas para ${participantId}:`, error.message);
            }
        }, 3000 + (Math.random() * 5000)); // 3-8 segundos
        
    } catch (error) {
        console.error('‚ùå Erro ao processar novo membro:', error);
    }
}

// Detectar novo membro pela primeira mensagem (backup)
async function detectarNovoMembro(grupoId, participantId, configGrupo) {
    // Esta fun√ß√£o agora √© s√≥ um backup caso o monitoramento autom√°tico falhe
    return;
}

// Registrar entrada de novo membro
async function registrarEntradaMembro(grupoId, participantId) {
    try {
        if (!membrosEntrada[grupoId]) {
            membrosEntrada[grupoId] = {};
        }
        
        membrosEntrada[grupoId][participantId] = new Date().toISOString();
        await salvarDadosMembros();
        
        console.log(`üìù Entrada registrada`);
    } catch (error) {
        console.error('‚ùå Erro ao registrar entrada de membro:', error);
    }
}

// Salvar dados de membros
async function salvarDadosMembros() {
    try {
        await fs.writeFile(ARQUIVO_MEMBROS, JSON.stringify(membrosEntrada));
    } catch (error) {
        console.error('‚ùå Erro ao salvar dados de membros:', error);
    }
}

// Enviar mensagem de boas-vindas para novos membros
async function enviarBoasVindas(grupoId, participantId) {
    try {
        console.log(`üëã Enviando boas-vindas`);
        
        // Registrar entrada do membro
        await registrarEntradaMembro(grupoId, participantId);
        
        // Obter informa√ß√µes do participante
        const contact = await client.getContactById(participantId);
        const nomeUsuario = contact.name || contact.pushname || participantId.replace('@c.us', '');
        
        // Obter configura√ß√£o do grupo
        const configGrupo = getConfiguracaoGrupo(grupoId);
        if (!configGrupo) {
            console.log(`‚ö†Ô∏è Grupo n√£o configurado`);
            return false;
        }
        
        // Usar mensagem personalizada do grupo ou padr√£o
        let mensagemBoasVindas = configGrupo.boasVindas || `üéâ *BOAS-VINDAS AO GRUPO!*

üëã Ol√° @NOME, seja bem-vindo!

ü§ñ *SISTEMA DE VENDAS 100% AUTOM√ÅTICO!*
üì± 1. Envie comprovante de pagamento aqui
‚ö° 2. Nosso sistema processa automaticamente
üìä 3. Participe do ranking di√°rio de compradores

üí∞ *COMANDOS √öTEIS:*
‚Ä¢ *tabela* - Ver pre√ßos de pacotes
‚Ä¢ *pagamento* - Ver formas de pagamento
‚Ä¢ *.ranking* - Ver ranking do grupo
‚Ä¢ *.meucodigo* - Gerar c√≥digo de refer√™ncia

üéÅ *SISTEMA DE REFER√äNCIAS:*
Voc√™ tem c√≥digo de refer√™ncia de algu√©m?
Use: *.convite C√ìDIGO* para ativar!

‚ú® *IMPORTANTE:* C√≥digos de refer√™ncia s√≥ funcionam para membros que entraram nos √∫ltimos 5 dias!

üöÄ Vamos come√ßar? Qualquer d√∫vida, pergunte no grupo!`;
        
        // Substituir placeholder @NOME pelo nome real
        mensagemBoasVindas = mensagemBoasVindas.replace('@NOME', `@${participantId.replace('@c.us', '')}`);
        
        // Enviar mensagem com men√ß√£o
        await client.sendMessage(grupoId, mensagemBoasVindas, {
            mentions: [participantId]
        });
        
        console.log(`‚úÖ Boas-vindas enviadas`);
        return true;
        
    } catch (error) {
        console.error(`‚ùå Erro ao enviar boas-vindas para ${participantId}:`, error);
        return false;
    }
}

// Verificar se usu√°rio √© eleg√≠vel para usar c√≥digo (√∫ltimos 5 dias)
function isElegivelParaCodigo(participantId, grupoId) {
    try {
        if (!membrosEntrada[grupoId] || !membrosEntrada[grupoId][participantId]) {
            console.log(`‚ö†Ô∏è Membro sem registro de entrada`);
            return false; // Se n√£o tem registro, n√£o √© eleg√≠vel
        }
        
        const dataEntrada = new Date(membrosEntrada[grupoId][participantId]);
        const agora = new Date();
        const limite5Dias = 5 * 24 * 60 * 60 * 1000; // 5 dias em ms
        
        const tempoNoGrupo = agora - dataEntrada;
        const elegivelTempo = tempoNoGrupo <= limite5Dias;
        
        console.log(`üîç Verificando elegibilidade - ${Math.floor(tempoNoGrupo / (24 * 60 * 60 * 1000))} dias no grupo`);
        
        return elegivelTempo;
    } catch (error) {
        console.error('‚ùå Erro ao verificar elegibilidade:', error);
        return false;
    }
}

// Carregar dados persistentes
async function carregarDadosReferencia() {
    try {
        // Carregar c√≥digos
        try {
            const dados = await fs.readFile(ARQUIVO_CODIGOS, 'utf8');
            codigosReferencia = JSON.parse(dados);
            console.log(`üìã ${Object.keys(codigosReferencia).length} c√≥digos de refer√™ncia carregados`);
        } catch (e) {
            codigosReferencia = {};
        }

        // Carregar refer√™ncias  
        try {
            const dados = await fs.readFile(ARQUIVO_REFERENCIAS, 'utf8');
            referenciasClientes = JSON.parse(dados);
            console.log(`üë• ${Object.keys(referenciasClientes).length} refer√™ncias de clientes carregadas`);
        } catch (e) {
            referenciasClientes = {};
        }

        // Carregar b√¥nus
        try {
            const dados = await fs.readFile(ARQUIVO_BONUS, 'utf8');
            bonusSaldos = JSON.parse(dados);
            console.log(`üí∞ ${Object.keys(bonusSaldos).length} saldos de b√¥nus carregados`);
        } catch (e) {
            bonusSaldos = {};
        }

        // Carregar saques
        try {
            const dados = await fs.readFile(ARQUIVO_SAQUES, 'utf8');
            pedidosSaque = JSON.parse(dados);
            console.log(`üè¶ ${Object.keys(pedidosSaque).length} pedidos de saque carregados`);
        } catch (e) {
            pedidosSaque = {};
        }

        // Carregar dados de entrada de membros
        try {
            const dados = await fs.readFile(ARQUIVO_MEMBROS, 'utf8');
            membrosEntrada = JSON.parse(dados);
            console.log(`üë• ${Object.keys(membrosEntrada).length} grupos com dados de entrada carregados`);
        } catch (e) {
            membrosEntrada = {};
        }

    } catch (error) {
        console.error('‚ùå Erro ao carregar dados de refer√™ncia:', error);
    }
}

// Salvar dados persistentes
// === SISTEMA DE SALVAMENTO OTIMIZADO ===
let salvamentoPendente = false;

async function salvarDadosReferencia() {
    // Evitar salvamentos simult√¢neos
    if (salvamentoPendente) return;
    salvamentoPendente = true;

    try {
        // Usar Promise.allSettled para n√£o falhar se um arquivo der erro
        const resultados = await Promise.allSettled([
            fs.writeFile(ARQUIVO_CODIGOS, JSON.stringify(codigosReferencia)),
            fs.writeFile(ARQUIVO_REFERENCIAS, JSON.stringify(referenciasClientes)),
            fs.writeFile(ARQUIVO_BONUS, JSON.stringify(bonusSaldos)),
            fs.writeFile(ARQUIVO_SAQUES, JSON.stringify(pedidosSaque))
        ]);

        // Log apenas se houve falhas
        const falhas = resultados.filter(r => r.status === 'rejected');
        if (falhas.length > 0) {
            console.error('‚ùå Algumas escritas falharam:', falhas.length);
        }
    } catch (error) {
        console.error('‚ùå Erro ao salvar dados de refer√™ncia:', error);
    } finally {
        salvamentoPendente = false;
    }
}

// === SALVAMENTO COM DEBOUNCE (OTIMIZA√á√ÉO) ===
let timeoutSalvamento = null;

function agendarSalvamento() {
    // Cancelar salvamento anterior se houver
    if (timeoutSalvamento) {
        clearTimeout(timeoutSalvamento);
    }

    // Agendar novo salvamento em 2 segundos
    timeoutSalvamento = setTimeout(async () => {
        agendarSalvamento();
        timeoutSalvamento = null;
    }, 2000);
}

// Gerar c√≥digo √∫nico
function gerarCodigoReferencia(remetente) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let codigo;
    do {
        codigo = '';
        for (let i = 0; i < 6; i++) {
            codigo += chars.charAt(Math.floor(Math.random() * chars.length));
        }
    } while (codigosReferencia[codigo]);
    
    return codigo;
}

// Processar b√¥nus de compra
async function processarBonusCompra(remetenteCompra, valorCompra) {
    console.log(`üéÅ Verificando b√¥nus para compra`);
    
    // Verificar se cliente tem refer√™ncia
    const referencia = referenciasClientes[remetenteCompra];
    if (!referencia) {
        console.log(`   ‚ùå Cliente n√£o tem refer√™ncia registrada`);
        return false;
    }

    // Verificar se ainda pode ganhar b√¥nus (m√°ximo 5 compras)
    if (referencia.comprasRealizadas >= 5) {
        console.log(`   ‚ö†Ô∏è Cliente j√° fez 5 compras, sem mais b√¥nus`);
        return false;
    }

    // Atualizar contador de compras
    referencia.comprasRealizadas++;
    
    // Creditar b√¥nus ao convidador
    const convidador = referencia.convidadoPor;
    if (!bonusSaldos[convidador]) {
        bonusSaldos[convidador] = {
            saldo: 0,
            detalhesReferencias: {},
            historicoSaques: [],
            totalReferencias: 0
        };
    }

    // Adicionar 200MB ao saldo
    const bonusAtual = 200;
    bonusSaldos[convidador].saldo += bonusAtual;
    
    // Atualizar detalhes da refer√™ncia
    if (!bonusSaldos[convidador].detalhesReferencias[remetenteCompra]) {
        bonusSaldos[convidador].detalhesReferencias[remetenteCompra] = {
            compras: 0,
            bonusGanho: 0,
            codigo: referencia.codigo,
            ativo: true
        };
    }
    
    bonusSaldos[convidador].detalhesReferencias[remetenteCompra].compras = referencia.comprasRealizadas;
    bonusSaldos[convidador].detalhesReferencias[remetenteCompra].bonusGanho += bonusAtual;
    
    // Enviar notifica√ß√£o de b√¥nus por refer√™ncia
    try {
        const nomeComprador = message.from.includes('@g.us') ? await obterNomeContato(remetenteCompra) : 'Cliente';
        const novoSaldo = bonusSaldos[convidador].saldo;
        const novoSaldoFormatado = novoSaldo >= 1024 ? `${(novoSaldo/1024).toFixed(2)}GB` : `${novoSaldo}MB`;
        
        await client.sendMessage(message.from, 
            `üéâ *B√îNUS CREDITADO!*\n\n` +
            `üíé @${convidador.replace('@c.us', '')}, recebeste *${bonusAtual}MB* de b√¥nus!\n\n` +
            `üë§ *Comprador:* @${remetenteCompra.replace('@c.us', '')}\n` +
            `üõí *Compra:* ${referencia.comprasRealizadas}¬™ de 5\n` +
            `üí∞ *Novo saldo:* ${novoSaldoFormatado}\n\n` +
            `${novoSaldo >= 1024 ? 'üöÄ *J√° podes sacar!* Use: *.sacar*' : '‚è≥ *Continua a convidar amigos!*'}`, {
            mentions: [convidador, remetenteCompra]
        });
    } catch (error) {
        console.error('‚ùå Erro ao enviar notifica√ß√£o de b√¥nus:', error);
    }

    // Salvar dados
    agendarSalvamento();
    
    console.log(`   ‚úÖ B√¥nus creditado: ${bonusAtual}MB (${referencia.comprasRealizadas}/5)`);
    
    return {
        convidador: convidador,
        bonusGanho: bonusAtual,
        compraAtual: referencia.comprasRealizadas,
        totalCompras: 5,
        novoSaldo: bonusSaldos[convidador].saldo
    };
}

// === FUN√á√ÉO PARA NORMALIZAR VALORES ===
function normalizarValor(valor) {
    if (typeof valor === 'number') return valor;
    if (typeof valor === 'string') {
        const valorLimpo = valor.replace(/[^\d]/g, '');
        return parseInt(valorLimpo) || 0;
    }
    return 0;
}

// === FUN√á√ÉO PARA CALCULAR VALOR DO PEDIDO ===
function calcularValorPedido(megas, precosGrupo) {
    const megasNum = parseInt(megas) || 0;
    if (precosGrupo && precosGrupo[megasNum]) {
        return precosGrupo[megasNum];
    }
    // Fallback: calcular valor baseado em pre√ßo por MB (assumindo ~12.5MT/GB)
    const valorPorMB = 12.5 / 1024; // ~0.012MT por MB
    return Math.round(megasNum * valorPorMB);
}

// === FUN√á√ÉO PARA VERIFICAR PAGAMENTO ===
async function verificarPagamentoIndividual(referencia, valorEsperado) {
    try {
        const valorNormalizado = normalizarValor(valorEsperado);

        console.log(`üîç REVENDEDORES: Verificando pagamento ${referencia} - ${valorNormalizado}MT (original: ${valorEsperado})`);

        const response = await axios.post(PAGAMENTOS_CONFIG.scriptUrl, {
            action: "buscar_por_referencia",
            referencia: referencia,
            valor: valorNormalizado
        }, {
            timeout: PAGAMENTOS_CONFIG.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (response.data && response.data.encontrado) {
            console.log(`‚úÖ REVENDEDORES: Pagamento encontrado!`);
            return true;
        }

        console.log(`‚ùå REVENDEDORES: Pagamento n√£o encontrado`);
        return false;

    } catch (error) {
        console.error(`‚ùå REVENDEDORES: Erro ao verificar pagamento:`, error.message);
        return false;
    }
}

// Base de dados de compradores
let historicoCompradores = {};
const ARQUIVO_HISTORICO = 'historico_compradores.json';

// Cache de administradores dos grupos
let adminCache = {};

// Cache para evitar logs repetidos de grupos
let gruposLogados = new Set();

// === COMANDOS CUSTOMIZADOS ===
let comandosCustomizados = {};
const ARQUIVO_COMANDOS = 'comandos_customizados.json';

// Configura√ß√£o de administradores GLOBAIS
const ADMINISTRADORES_GLOBAIS = [
    '258874100607@c.us',
    '258871112049@c.us',
    '258845356399@c.us', 
    '258840326152@c.us', 
    '258852118624@c.us',
    '23450974470333@lid'   // ID interno do WhatsApp para 852118624
    // Removido temporariamente para testar verifica√ß√£o de grupo: '245075749638206@lid'
];

// Mapeamento de IDs internos (@lid) para n√∫meros reais (@c.us)
const MAPEAMENTO_IDS = {
    '23450974470333@lid': '258852118624@c.us',  // Seu ID
    '245075749638206@lid': null  // Ser√° identificado automaticamente
};

// === CONFIGURA√á√ÉO DE MODERA√á√ÉO ===
const MODERACAO_CONFIG = {
    ativado: {
        '258820749141-1441573529@g.us': true,
        '120363152151047451@g.us': true,
        '258840161370-1471468657@g.us': true
    },
    detectarLinks: true,
    apagarMensagem: true,
    removerUsuario: true,
    excecoes: [
        '258861645968@c.us',
        '258871112049@c.us', 
        '258852118624@c.us'
    ]
};

// Configura√ß√£o para cada grupo
const CONFIGURACAO_GRUPOS = {
    '258820749141-1441573529@g.us': {
        nome: 'Data Store - Vodacom',
        boasVindas: `üéâ *BOAS-VINDAS AO GRUPO!*

üëã Ol√° @NOME, seja bem-vindo!

ü§ñ *SISTEMA DE VENDAS 100% AUTOM√ÅTICO!*
üì± 1. Envie comprovante de pagamento aqui
‚ö° 2. Nosso sistema processa automaticamente
üìä 3. Participe do ranking di√°rio de compradores

üí∞ *COMANDOS √öTEIS:*
‚Ä¢ *tabela* - Ver pre√ßos de pacotes
‚Ä¢ *pagamento* - Ver formas de pagamento
‚Ä¢ *.ranking* - Ver ranking do grupo
‚Ä¢ *.meucodigo* - Gerar c√≥digo de refer√™ncia

üéÅ *SISTEMA DE REFER√äNCIAS:*
Voc√™ tem c√≥digo de refer√™ncia de algu√©m?
Use: *.convite C√ìDIGO* para ativar!

‚ú® *IMPORTANTE:* C√≥digos de refer√™ncia s√≥ funcionam para membros que entraram nos √∫ltimos 5 dias!

üöÄ Vamos come√ßar? Qualquer d√∫vida, pergunte no grupo!`,
        tabela: `SUPER PROMO√á√ÉO  DE üõú‚ìÇEGAS‚úÖ VODACOM A MELHOR PRE√áO DO MERCADO - 04-05/09/2025

üìÜ PACOTES DI√ÅRIOS
900MB üíé 15MT üíµüíΩ
1100MB üíé 17MT üíµüíΩ
1200MB üíé 20MT üíµüíΩ
2200MB üíé 34MT üíµüíΩ
3300MB üíé 51MT üíµüíΩ
4400MB üíé 68MT üíµüíΩ
5500MB üíé 85MT üíµüíΩ
10240MB üíé 170MT üíµüíΩ ‚ûï B√≥nus 1GB na pr√≥xima compra üéÅ
20480MB üíé 340MT üíµüíΩ ‚ûï B√≥nus 2GB na pr√≥xima¬†compra¬†üéÅ

üìÖ PACOTES SEMANAIS

3072 + 700MB üíé 105MT üíµüíΩ
5120 + 700MB üíé 155MT üíµüíΩ
10240 + 700MB üíé 210MT üíµüíΩ
15360 + 700MB üíé 290MT üíµüíΩ
20480 + 700MB üíé 360MT üíµüíΩ

üìÖ PACOTES MENSAIS

12.8GB üíé 270MT üíµüíΩ
22.8GB üíé 435MT üíµüíΩ
32.8GB üíé 605MT üíµüíΩ
52.8GB üíé 945MT üíµüíΩ
102.8GB¬†üíé¬†1605MT¬†üíµüíΩ


PACOTES DIAMANTE MENSAIS
Chamadas + SMS ilimitadas + 12GB üíé 460MT üíµ
Chamadas + SMS ilimitadas + 24GB üíé 820MT üíµ
Chamadas + SMS ilimitadas + 50GB üíé 1550MT üíµ
Chamadas + SMS ilimitadas + 100GB üíé 2250MT üíµ

‚ö† NB: V√°lido apenas¬†para¬†Vodacom
`,

        pagamento: `FORMAS DE PAGAMENTO ATUALIZADAS
 
1- M-PESA 
N√öMERO: 848715208
NOME:  NATACHA ALICE

N√öMERO: 871112049
NOME: NATACHA ALICE`
    },

    '120363402160265624@g.us': {
        nome: 'Treinamento IA',
        tabela: `PROMO√á√ÉO DE üõú‚ìÇEGAS‚úÖ VODACOM A MELHOR PRE√áO DO MERCADO 
üìÜ PACOTES DI√ÅRIOS 


512MB üíé 10MT üíµüíΩ
850MB üíé 15MT üíµüíΩ
1024MB üíé 17MT üíµüíΩ
1200MB üíé 20MT üíµüíΩ
2048MB üíé 34MT üíµüíΩ
3072MB üíé 51MT üíµüíΩ
4096MB üíé 68MT üíµüíΩ
5120MB üíé 85MT üíµüíΩ
10240MB üíé 170MT üíµüíΩ
20480MB üíé 340MT üíµüíΩ 

üìÖ PACOTES SEMANAIS
3072 + 700MB üíé 105MT üíµüíΩ
5120 + 700MB üíé 155MT üíµüíΩ
10240 + 700MB üíé 300MT üíµüíΩ
15360 + 700MB üíé 455MT üíµüíΩ
20480 + 700MB üíé 600MT üíµüíΩ

üìÖ PACOTES MENSAIS
‚ö† Para ativar estes pacotes, o Txuna Cr√©dito n√£o pode estar ativo
12.8GB üíé 255MT üíµüíΩ
22.8GB üíé 435MT üíµüíΩ
32.8GB üíé 605MT üíµüíΩ
52.8GB üíé 945MT üíµüíΩ
102.8GB üíé 1605MT üíµüíΩ

PACOTES DIAMANTE MENSAIS
Chamadas + SMS ilimitadas + 12GB üíé 460MT üíµ
Chamadas + SMS ilimitadas + 24GB üíé 820MT üíµ
Chamadas + SMS ilimitadas + 50GB üíé 1550MT üíµ
Chamadas + SMS ilimitadas + 100GB üíé 2250MT üíµ
‚ö† NB: V√°lido apenas para Vodacom


üöÄ Oferecemos sempre¬†o¬†melhor!*

`,

        pagamento: `üÖºüÖ¥üÖ∂üÖ∞üÜÇ üÖøüÜÅüÖæüÖºüÖæ    üí≥ üõí‚õî FORMAS DE PAGAMENTO:‚õîüõíüí≥


      ‚óè E-MOLA: 868019487üõí
      ‚óè M-PESA: 851841990üõí

NOME:   Alice Armando Nhaquilaüìù

!¬° üìÇ‚õîüõí ENVIE O SEU COMPROVATIVO NO GRUPO,  JUNTAMENTE COM O N√öMERO QUE VAI RECEBER¬†OS¬†MB‚úÖ‚õîüõí
`
    },

    '258840161370-1471468657@g.us': {
        nome: 'Venda Autom√°tica 24/7',
        tabela: `TABELA ATUALIZADA
10/10/2026 - 07:30:48 

___________________________

 PACOTE DI√ÅRIO B√ÅSICO( 24H‚è±) 
1024MB    - 17,00 MT
1200MB    - 20,00 MT
2048MB   - 34,00 MT
2200MB    - 40,00 MT
3096MB    - 51,00 MT
4096MB    - 68,00 MT
5120MB     - 85,00 MT
6144MB    - 102,00 MT
7168MB    - 119,00 MT
8192MB    - 136,00 MT
9144MB    - 153,00 MT
10240MB  - 170,00 MT

 PACOTE DI√ÅRIO PREMIUM ( 3 DIAS üóì) 
Megabyte Renov√°veis!
2000MB  - 44,00 MT
3000MB  - 66,00 MT
4000MB  - 88,00 MT
5000MB - 109,00 MT
6000MB  - 133,00 MT

PACOTE SEMANAL B√ÅSICO (5 Diasüóì)
Megabyte Renov√°veis!
1700MB - 45,00MT
2900MB - 80,00MT
3400MB - 110,00MT
5500MB - 150,00MT
7800MB - 200,00MT
11400MB - 300,00MT 

 PACOTE SEMANAL PREMIUM ( 15 DIAS üóì ) 
Megabyte Renov√°veis!
5000MB - 149,00 MT
8000MB - 201,00 MT
10000MB - 231,00 MT
20000MB - 352,00 MT

PACOTE MENSAL PREMIUM (30 diasüóì)
Megabyte Renov√°veis!
3198MB   - 104,00MT
5298MB   - 184,00MT
8398MB   - 229,00MT
10498MB   - 254,00MT
12598MB   - 294,00MT
15698MB   - 349,00MT
18798MB   - 414,00MT
20898MB   - 468,00MT
25998MB   - 529,00MT

PACOTE MENSAL EXCLUSIVO (30 diasüóì)
N√£o pode ter xtuna cr√©dito
32.8GB   - 649,00MT
51.2GB   - 1049,00MT
60.2GB   - 124900MT
80.2GB   - 1449,00MT
100.2GB   - 1700,00MT

üî¥üî¥ VODACOM
‚ûñChamadas +SMS ILIMITADAS ‚ûñp/todas as redes +GB‚ûñ

‚ûñ SEMANAL (7dias)‚ûñ
280mt = Ilimitado+ 7.5GB

Mensal(30dias):
450MT - Ilimitado + 11.5GB.
500MT - Ilimitado + 14.5GB.
700MT - Ilimitado + 26.5GB.
1000MT - Ilimitado + 37.5GB.
1500MT - Ilimitado + 53.5GB
2150MT - Ilimitado + 102.5GB

PARA OS PACOTES MENSAIS, N√ÉO PODE TER TXUNA CR√âDITO.

üü†üü† MOVITEL
‚ûñChamadas +SMS ILIMITADAS ‚ûñp/todas as redes +GB‚ûñ

‚ûñ SEMANAL (7dias)‚ûñ
280mt = Ilimitado+ 7.1GB

üü†‚ûñ MENSAL (30dias)‚ûñ p./tds redes
450mt = Ilimitado+ 9GB
950mt = Ilimitado+ 23GB
1450mt = Ilimitado+ 38GB
1700mt = Ilimitado+ 46GB
1900mt = Ilimitado+ 53GB
2400mt = ilimitado+ 68GB

Importante üö®: Envie o valor que consta¬†na¬†tabela!
`,

        pagamento: `‚ï≠‚îÅ‚îÅ‚îÅ‚îõ üí∏  Ôº¶ÔºØÔº≤Ôº≠Ôº°Ôº≥ Ôº§Ôº• Ôº∞Ôº°ÔºßÔº°Ôº≠Ôº•ÔºÆÔº¥ÔºØ: 
‚îÉ
‚îÉ ü™ô E-Mola: (Gl√≥ria) üë©‚Äçüíª
‚îÉ     860186270  
‚îÉ
‚îÉ ü™ô M-Pesa:  (Leonor)üë®‚Äçüíª
‚îÉ     857451196  
‚îÉ
‚îÉ
‚îÉ ‚ö† IMPORTANTE:  
‚îÉ     ‚ñ™ Envie o comprovativo em forma de mensagem e o n√∫mero para receber r√°pido!
‚îÉ
‚îÉ‚îÉ
‚ï∞‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  
       üöÄ O futuro √© agora. Vamos?`
    },
    '120363228868368923@g.us': {
    nome: 'VENDA DE MEGAS',
    tabela: `ùóßùóÆùóØùó≤ùóπùóÆ ùóÆùó∞ùòÅùòÇùóÆùóπùó∂ùòáùóÆdo ùó±ùó≤ ùòÉùóºùó±ùóÆùó∞ùóºùó∫


ùóóùó∂ùóÆùóøùó∂ùóº
‚úÖPODE TER TXUNA CR√âDITO


ùü≠024Mùóï__ùü≠ùü¥ ùó†ùóß
ùüÆ048Mùóï__ùüØ6ùó†ùóß
ùüØ072MB ___ ùü±4ùó†ùóß
ùü∞096MB__ùü≥0ùó†ùóß
ùü±120Mùóï ___ ùüµùü¨ùó†ùóß
ùü≠0240MB___ùü≠8ùü¨ùó†ùóß

ùó¶ùó≤ùó∫ùóÆùóªùóÆùóπ
‚ùé N√ÉO PODE TER TXUNA CR√âDITO

ùü∞5ùó†ùóß__ùü≠ùü≥41Mùóï
80ùó†ùóß__ùüÆùüµ70Mùóï
90ùó†ùóß__ùüØùü∞82Mùóï
ùü≠40ùó†ùóß___ùü±325Mùóï
ùü≠80ùó†ùóß___ùü≥270Mùóï

ùêåùêûùêßùê¨ùêöùê•
‚ùé N√ÉO PODE TER TXUNA CR√âDITO

ùü≤057Mùóï__ùüÆùü¨ùü¨ùó†ùóß
ùü¥057MB__ùüÆùüØùü¨ùó†ùóß
ùü≠ùü¨057MB___ùüÆ6ùü¨ùó†ùóß
ùüÆùü¨057Mùóï___ùü∞ùü±ùü¨ùó†ùóß

ùóóùó∂ùóÆùó∫ùóÆùóªùòÅùó≤ ùó±ùó≤ ùó©ùóºùó±ùóÆùó∞ùóºùó∫
‚ùé N√ÉO PODE TER TXUNA CR√âDITO

ùó†ùó≤ùóªùòÄùóÆùóπ (ùüØùü¨ùóóùó∂ùóÆùòÄ)
‚ø°ùü∞50ùó†ùòÅ =ùóñùóµùóÆùó∫ùóÆùó±ùóÆùòÄ ùó∂ùóπùó∂ùó∫ùó∂ùòÅùóÆùó±ùóÆùòÄ +ùü≠ùü≠ùóöùóï+ùó¶ùó†ùó¶
‚ø¢ùü±50 =ùóñùóµùóÆùó∫ùóÆùó±ùóÆùòÄ ùó∂ùóπùó∂ùó∫ùó∂ùòÅùóÆùó±ùóÆùòÄ +ùü≠ùü±ùóöùóï+ùó¶ùó†ùó¶
‚ø£ùü≥50=ùóñùóµùóÆùó∫ùóÆùó±ùóÆùòÄ ùó∂ùóπùó∂ùó∫ùó∂ùòÅùóÆùó±ùóÆùòÄ +ùüÆùü±ùóöùóï+ùó¶ùó†ùó¶
‚ø§ùü≠050=ùóñùóµùóÆùó∫ùóÆùó±ùóÆùòÄ ùó∂ùóπùó∂ùó∫ùó∂ùòÅùóÆùó±ùóÆùòÄ +ùü∞ùüÆùóöùóï+ùó¶ùó†ùó¶

`,
    pagamento: `üí≥ FORMAS/ PAGAMENTOS :‚§µ
- üì≤ ùóò-ùó†ùó¢ùóüùóî: 868440408:
- *JOSE TOMAS*
- üì≤ ùó†-ùó£ùóòùó¶ùóî 850189315:
- *JOSE TOM√ÅS*

üì© Envie o seu comprovantivo no grupo, juntamente com o n√∫mero que vai receber¬†os¬†dados.`
},'120363022366545020@g.us': {
        nome: 'Megas VIP',
        boasVindas: `üéâ *BOAS-VINDAS AO MEGAS VIP!*

üëã Ol√° @NOME, seja bem-vindo ao melhor grupo de internet!

ü§ñ *SISTEMA 100% AUTOM√ÅTICO - SEM DEMORAS!*
‚ö° Envie seu comprovante e receba instantaneamente
üèÜ Sistema mais r√°pido de Mo√ßambique
üìä Ranking di√°rio com pr√™mios especiais

üí∞ *COMANDOS:*
‚Ä¢ *tabela* - Ver pre√ßos VIP
‚Ä¢ *pagamento* - Formas de pagamento
‚Ä¢ *.ranking* - Ver seu ranking

üéÅ *B√îNUS DE REFER√äNCIA:*
Indique amigos e ganhe MB extras!
Use: *.meucodigo* para seu c√≥digo

üöÄ *VANTAGENS EXCLUSIVAS:*
‚úÖ Processamento em tempo real
‚úÖ Suporte 24/7
‚úÖ Pre√ßos especiais
‚úÖ Sem taxas escondidas

Bem-vindo √† fam√≠lia VIP! üî•`,
        tabela: `üö®üì¢MEGABYTES DA VODACOMüì¢üö®

üì¶PACOTE DI√ÅRIOüì¶

üõú512MB = 10MT
üõú1024MB = 18MT
üõú2048MB = 36MT
üõú3072MB = 54MT
üõú4096MB = 72MT
üõú5120MB = 90MT
üõú6144MB = 108MB
üõú7168MB = 126MB
üõú8192MB = 144MB
üõú9216MB = 162MB
üõú10240MB = 180MT
üõú20480MB = 360MT

PACOTE SEMANALüõíüì¶
‚ö† Vai receber 100MB por dia durante 6 dias, totalizando +0.6GB. ‚ö†

üõú2.0GB = 65MT
üõú3.0GB = 85MT
üõú5.0GB = 130MT
üõú7.0GB = 175MT 
üõú10.0GB = 265MT
üõú14.0GB = 362MT

üì¶PACOTE MENSALüì¶
‚ö†N√£o deve ter txuna cr√©dito‚ö†

üìä2.8GB = 95MT
üìä3.8GB = 125MT
üìä4.8GB = 145MT
üìä5.8GB = 165MT
üìä6.8GB = 195MT
üìä7.8GB = 215MT
üìä10.8GB = 285MT
üìä12.8GB = 345MT
üìä20.8GB = 565MT


FORMA DE PAGAMENTO:
üí≥üí∏
M-Pesa: 853529033 üì±
- Erc√≠lio Uanela 
e-Mola: 865627840 üì±
- Alexandre Uanela 

Adquira j√° os teus megas com seguran√ßa, confian√ßa¬†e¬†rapidez!üö®üî•
`,

        pagamento: `FORMAS DE PAGAMENTOüí∞üí∂

üìå M-PESA: 853529033 
   Nome: Erc√≠lio Uanela 

üìå E-MOLA: 865627840 
    Nome: Alexandre Uanela  

üìÆ _Apos a transfer√™ncia do valor envie o comprovativo da transa√ß√£o ou a chave da mensagem üì∏üìÇ

üöÄ O futuro √© agora!¬†Vamos?¬†üî•üõí
`
    },
    '120363152151047451@g.us': {
        nome: 'MEGA PROMO VODACOM',
        tabela: `üî• MEGA PROMO VODACOM
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

PACOTES DI√ÅRIOS 24h
1050MB = 18MT
1200MB = 20MT
2400MB = 40MT
3600MB = 60MT
10240MB = 180MT

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

PLANO SEMANAL (7 DIAS)
3GB = 97MT
5GB = 147MT
7GB = 196MT
10GB = 296MT

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

PACOTES MENSAIS
5GB = 150MT
10GB = 280MT
20GB = 480MT

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ILIMITADO 30 DIAS
‚úÖ 11GB + Chamadas & SMS ilimitados ‚Äì 450MT
‚úÖ 15GB + Chamadas & SMS ilimitados ‚Äì 550MT
‚úÖ 20GB + Chamadas & SMS ilimitados ‚Äì 650MT
‚úÖ 25GB + Chamadas & SMS ilimitados ‚Äì 750MT
‚úÖ 50GB + Chamadas & SMS ilimitados ‚Äì 1250MT

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö† NB: Para activar o pacote semanal e mensal n√£o pode ter¬†nenhum¬†cr√©dito
`,
        pagamento: `üÖºüÖ¥üÖ∂üÖ∞üÜÇ üÖøüÜÅüÖæüÖºüÖæ    üí≥ üõí‚õî FORMAS DE PAGAMENTO:‚õîüõíüí≥


      ‚óè E-MOLA: 868019487üõí
      ‚óè M-PESA: 851841990üõí

NOME:   Alice Armando Nhaquilaüìù

!¬° üìÇ‚õîüõí ENVIE O SEU COMPROVATIVO NO GRUPO,  JUNTAMENTE COM O N√öMERO QUE VAI RECEBER OS MB‚úÖ‚õîüõí`
    }
};

// === FUN√á√ÉO GOOGLE SHEETS ===

// Fun√ß√£o para retry autom√°tico
async function tentarComRetry(funcao, maxTentativas = 3, delay = 2000) {
    for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
        try {
            return await funcao();
        } catch (error) {
            console.log(`‚ö†Ô∏è Tentativa ${tentativa}/${maxTentativas} falhou: ${error.message}`);
            
            if (tentativa === maxTentativas) {
                throw error; // √öltima tentativa, propagar erro
            }
            
            // Aguardar antes da pr√≥xima tentativa
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}
async function enviarParaGoogleSheets(referencia, valor, numero, grupoId, grupoNome, autorMensagem) {
    // Formato igual ao Bot Atacado: transacao j√° concatenada
    const transacaoFormatada = `${referencia}|${valor}|${numero}`;
    
    const dados = {
        transacao: transacaoFormatada,  // Formato concatenado igual ao Bot Atacado
        grupo_id: grupoId,
        sender: 'WhatsApp-Bot',  // Identificar origem
        message: `Dados enviados pelo Bot: ${transacaoFormatada}`,
        timestamp: new Date().toISOString()
    };
    
    try {
        console.log(`üìä Enviando para Google Sheets: ${referencia}`);
        console.log(`üîç Dados enviados:`, JSON.stringify(dados, null, 2));
        console.log(`üîó URL destino:`, GOOGLE_SHEETS_CONFIG.scriptUrl);
        
       const response = await axios.post(GOOGLE_SHEETS_CONFIG.scriptUrl, dados, {
    timeout: GOOGLE_SHEETS_CONFIG.timeout,
    headers: {
        'Content-Type': 'application/json',
        'X-Bot-Source': 'WhatsApp-Bot'
    },
    // Configura√ß√£o de retry
    validateStatus: function (status) {
        return status < 500; // Resolve apenas se status < 500
    }
});
        
        // Google Apps Script agora retorna JSON
        const responseData = response.data;
        console.log(`üì• Resposta Google Sheets:`, JSON.stringify(responseData, null, 2));

        // Verificar se √© uma resposta JSON v√°lida
        if (typeof responseData === 'object') {
            if (responseData.success) {
                console.log(`‚úÖ Google Sheets: Dados enviados!`);
                return { sucesso: true, referencia: responseData.referencia, duplicado: false };
            } else if (responseData.duplicado) {
                console.log(`‚ö†Ô∏è Google Sheets: Pedido duplicado detectado - ${responseData.referencia} (Status: ${responseData.status_existente})`);
                return {
                    sucesso: false,
                    duplicado: true,
                    referencia: responseData.referencia,
                    status_existente: responseData.status_existente,
                    message: responseData.message
                };
            } else {
                throw new Error(responseData.message || 'Erro desconhecido');
            }
        } else {
            // Fallback para compatibilidade com resposta em texto
            const responseText = String(responseData);
            if (responseText.includes('Sucesso!')) {
                console.log(`‚úÖ Google Sheets: Dados enviados!`);
                return { sucesso: true, row: 'N/A', duplicado: false };
            } else if (responseText.includes('Erro:')) {
                throw new Error(responseText);
            } else {
                throw new Error(`Resposta inesperada: ${responseText}`);
            }
        }
        
    } catch (error) {
        console.error(`‚ùå Erro Google Sheets [${grupoNome}]: ${error.message}`);
        return { sucesso: false, erro: error.message };
    }
}

// === FUN√á√ÉO PRINCIPAL PARA TASKER ===
async function enviarParaTasker(referencia, valor, numero, grupoId, autorMensagem) {
    const grupoNome = getConfiguracaoGrupo(grupoId)?.nome || 'Desconhecido';
    const timestamp = new Date().toLocaleString('pt-BR');
    const linhaCompleta = `${referencia}|${valor}|${numero}`;
    
    console.log(`üìä ENVIANDO PARA GOOGLE SHEETS [${grupoNome}]: ${linhaCompleta}`);
    
    // Armazenar localmente (backup)
    dadosParaTasker.push({
        dados: linhaCompleta,
        grupo_id: grupoId,
        grupo: grupoNome,
        autor: autorMensagem,
        timestamp: timestamp,
        enviado: false,
        metodo: 'pendente'
    });
    
    // === TENTAR GOOGLE SHEETS PRIMEIRO ===
    const resultado = await enviarParaGoogleSheets(referencia, valor, numero, grupoId, grupoNome, autorMensagem);
    
    if (resultado.sucesso) {
        // Marcar como enviado
        dadosParaTasker[dadosParaTasker.length - 1].enviado = true;
        dadosParaTasker[dadosParaTasker.length - 1].metodo = 'google_sheets';
        dadosParaTasker[dadosParaTasker.length - 1].row = resultado.row;
        console.log(`‚úÖ [${grupoNome}] Enviado para Google Sheets! Row: ${resultado.row}`);

        // === REGISTRAR COMPRA PENDENTE NO SISTEMA DE COMPRAS ===
        if (sistemaCompras) {
            // Extrair apenas o n√∫mero do autorMensagem (remover @c.us se houver)
            const numeroRemetente = autorMensagem.replace('@c.us', '');
            console.log(`üîç DEBUG COMPRA: autorMensagem="${autorMensagem}" | numeroRemetente="${numeroRemetente}" | numero="${numero}"`);
            await sistemaCompras.registrarCompraPendente(referencia, numero, valor, numeroRemetente, grupoId);
        }
    } else if (resultado.duplicado) {
        // Remover da lista local j√° que √© duplicado
        dadosParaTasker.pop();
        console.log(`üõë [${grupoNome}] Pedido duplicado detectado: ${referencia}`);

        // Retornar informa√ß√µes do duplicado para o bot processar
        return {
            duplicado: true,
            referencia: resultado.referencia,
            status_existente: resultado.status_existente,
            message: resultado.message
        };
    } else {
        // Fallback para WhatsApp se Google Sheets falhar
        console.log(`üîÑ [${grupoNome}] Google Sheets falhou, usando WhatsApp backup...`);
        enviarViaWhatsAppTasker(linhaCompleta, grupoNome, autorMensagem);
        dadosParaTasker[dadosParaTasker.length - 1].metodo = 'whatsapp_backup';
    }
    
    // === BACKUP REMOVIDO - OTIMIZA√á√ÉO ===
    // N√£o salva mais arquivos .txt desnecess√°rios
    
    // Manter apenas √∫ltimos 100 registros
    if (dadosParaTasker.length > 100) {
        dadosParaTasker = dadosParaTasker.slice(-100);
    }
    
    return linhaCompleta;
}

function enviarViaWhatsAppTasker(linhaCompleta, grupoNome, autorMensagem) {
    const item = {
        conteudo: linhaCompleta, // Apenas: referencia|valor|numero
        autor: autorMensagem,
        grupo: grupoNome,
        timestamp: Date.now(),
        id: Date.now() + Math.random(),
        tipo: 'tasker_data_backup'
    };

    filaMensagens.push(item);
    console.log(`üì± WhatsApp Backup ‚Üí Tasker: ${linhaCompleta}`);

    if (!processandoFila) {
        processarFila();
    }
}

// === FUN√á√ÉO REMOVIDA PARA OTIMIZA√á√ÉO ===
// N√£o salva mais arquivos .txt desnecess√°rios
// async function salvarArquivoTasker() - REMOVIDA

function obterDadosTasker() {
    return dadosParaTasker;
}

function obterDadosTaskerHoje() {
    const hoje = new Date().toDateString();
    return dadosParaTasker.filter(item => {
        const dataItem = new Date(item.timestamp).toDateString();
        return dataItem === hoje;
    });
}

// === FUN√á√ïES PARA TASKER - SISTEMA DE PACOTES ===
function obterDadosPacotesTasker() {
    if (!sistemaPacotes) return [];
    
    const clientes = Object.values(sistemaPacotes.clientesAtivos);
    return clientes.map(cliente => ({
        numero: cliente.numero,
        referenciaOriginal: cliente.referenciaOriginal,
        tipoPacote: cliente.tipoPacote,
        diasRestantes: cliente.diasRestantes,
        proximaRenovacao: cliente.proximaRenovacao,
        status: cliente.status,
        grupoId: cliente.grupoId
    }));
}

function obterRenovacoesPendentesTasker() {
    if (!sistemaPacotes) return [];
    
    const agora = new Date();
    const proximas6h = new Date(agora.getTime() + (6 * 60 * 60 * 1000));
    
    const clientes = Object.values(sistemaPacotes.clientesAtivos);
    return clientes.filter(cliente => {
        const proximaRenovacao = new Date(cliente.proximaRenovacao);
        return proximaRenovacao <= proximas6h && cliente.diasRestantes > 0;
    }).map(cliente => ({
        numero: cliente.numero,
        referenciaOriginal: cliente.referenciaOriginal,
        tipoPacote: cliente.tipoPacote,
        proximaRenovacao: cliente.proximaRenovacao,
        diasRestantes: cliente.diasRestantes
    }));
}

// === COMANDOS CUSTOMIZADOS - FUN√á√ïES ===

async function carregarComandosCustomizados() {
    try {
        const data = await fs.readFile(ARQUIVO_COMANDOS, 'utf8');
        comandosCustomizados = JSON.parse(data);
        console.log(`üìù Comandos customizados carregados: ${Object.keys(comandosCustomizados).length} grupos`);
    } catch (error) {
        comandosCustomizados = {};
        console.log('üìù Arquivo de comandos n√£o existe, criando estrutura vazia');
    }
}

async function salvarComandosCustomizados() {
    try {
        await fs.writeFile(ARQUIVO_COMANDOS, JSON.stringify(comandosCustomizados));
        console.log('‚úÖ Comandos customizados salvos');
    } catch (error) {
        console.error('‚ùå Erro ao salvar comandos:', error);
    }
}

function parsearComandoCustomizado(texto) {
    // Regex para capturar: .addcomando Nome_do_comando(resposta)
    const regex = /^\.addcomando\s+(\w+)\s*\((.+)\)$/s;
    const match = texto.match(regex);
    
    if (match) {
        return {
            nome: match[1].toLowerCase(),
            resposta: match[2].trim()
        };
    }
    return null;
}

async function adicionarComandoCustomizado(chatId, nomeComando, resposta, autorId) {
    if (!comandosCustomizados[chatId]) {
        comandosCustomizados[chatId] = {};
    }
    
    comandosCustomizados[chatId][nomeComando] = {
        resposta: resposta,
        criadoPor: autorId,
        criadoEm: new Date().toISOString()
    };
    
    await salvarComandosCustomizados();
    console.log(`‚úÖ Comando '${nomeComando}' adicionado ao grupo ${chatId}`);
}

async function removerComandoCustomizado(chatId, nomeComando) {
    if (comandosCustomizados[chatId] && comandosCustomizados[chatId][nomeComando]) {
        delete comandosCustomizados[chatId][nomeComando];
        
        // Se n√£o h√° mais comandos no grupo, remove a entrada do grupo
        if (Object.keys(comandosCustomizados[chatId]).length === 0) {
            delete comandosCustomizados[chatId];
        }
        
        await salvarComandosCustomizados();
        console.log(`üóëÔ∏è Comando '${nomeComando}' removido do grupo ${chatId}`);
        return true;
    }
    return false;
}

function executarComandoCustomizado(chatId, comando) {
    if (comandosCustomizados[chatId] && comandosCustomizados[chatId][comando]) {
        return comandosCustomizados[chatId][comando].resposta;
    }
    return null;
}

// === FUN√á√ïES AUXILIARES ===

function detectarPerguntaPorNumero(mensagem) {
    const texto = mensagem.toLowerCase();
    
    const padroes = [
        /qual\s+(√©\s+)?(o\s+)?n√∫mero/i,
        /n√∫mero\s+(de\s+)?(contato|suporte|atendimento)/i,
        /como\s+(falar|contactar|entrar em contacto)/i,
        /preciso\s+(de\s+)?(ajuda|suporte|n√∫mero)/i,
        /onde\s+(posso\s+)?falar/i,
        /tem\s+(n√∫mero|contacto|suporte)/i,
        /quero\s+falar\s+com/i,
        /atendimento/i,
        /suporte/i,
        /admin/i,
        /administrador/i,
        /respons√°vel/i,
        /quem\s+(√©\s+)?respons√°vel/i,
        /como\s+contactar/i,
        /n√∫mero\s+do\s+admin/i
    ];
    
    return padroes.some(padrao => padrao.test(texto));
}

function isAdministrador(numero) {
    return ADMINISTRADORES_GLOBAIS.includes(numero);
}

function isGrupoMonitorado(chatId) {
    return CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
}

function getConfiguracaoGrupo(chatId) {
    return CONFIGURACAO_GRUPOS[chatId] || null;
}

// Fun√ß√£o para resolver ID interno (@lid) para n√∫mero real (@c.us)
function resolverIdReal(participantId, adminsEncontrados) {
    // Se j√° √© @c.us, retorna como est√°
    if (participantId.endsWith('@c.us')) {
        return participantId;
    }
    
    // Se tem mapeamento conhecido, usa ele
    if (MAPEAMENTO_IDS[participantId]) {
        return MAPEAMENTO_IDS[participantId];
    }
    
    // Se √© @lid, tenta encontrar correspond√™ncia nos admins
    if (participantId.endsWith('@lid')) {
        // Para agora, retorna o pr√≥prio ID para permitir compara√ß√£o direta
        return participantId;
    }
    
    return participantId;
}

async function isAdminGrupo(chatId, participantId) {
    try {
        console.log(`üîç Verificando admin: chatId=${chatId}, participantId=${participantId}`);
        
        if (adminCache[chatId] && adminCache[chatId].timestamp > Date.now() - 300000) {
            const { admins, mapeamentoLidToCus } = adminCache[chatId];
            console.log(`üìã Usando cache...`);
            
            // Usar mapeamento para verificar se √© admin
            const isAdmin = verificarAdminComMapeamento(participantId, admins, mapeamentoLidToCus);
            console.log(`‚úÖ Cache - ${participantId} √© admin? ${isAdmin}`);
            return isAdmin;
        }

        console.log(`üîÑ Cache expirado/inexistente, buscando admins do grupo...`);
        const chat = await client.getChatById(chatId);
        const participants = await chat.participants;
        const admins = participants.filter(p => p.isAdmin || p.isSuperAdmin);
        
        console.log(`üë• Participantes do grupo: ${participants.length}`);
        // console.log(`üëë Admins (@c.us): ${admins.map(a => a.id._serialized).join(', ')}`);
        
        const participantesLid = participants.filter(p => p.id._serialized.endsWith('@lid'));
        const participantesCus = participants.filter(p => p.id._serialized.endsWith('@c.us'));
        
        console.log(`üîç Participantes @lid: ${participantesLid.map(p => p.id._serialized).join(', ')}`);
        console.log(`üîç Participantes @c.us: ${participantesCus.map(p => p.id._serialized).join(', ')}`);
        // console.log(`üéØ Procurando por: ${participantId}`);
        
        // ESTRAT√âGIA ADICIONAL: Verificar se o participantId espec√≠fico tem flag de admin
        let adminDireto = false;
        const participanteEspecifico = participants.find(p => p.id._serialized === participantId);
        if (participanteEspecifico) {
            adminDireto = participanteEspecifico.isAdmin || participanteEspecifico.isSuperAdmin;
            // console.log(`üéØ Participante ${participantId} encontrado! isAdmin: ${participanteEspecifico.isAdmin}, isSuperAdmin: ${participanteEspecifico.isSuperAdmin}`);
        } else {
            console.log(`‚ö†Ô∏è Participante ${participantId} N√ÉO encontrado na lista de participantes!`);
        }
        
        // CRIAR MAPEAMENTO AUTOM√ÅTICO
        const mapeamentoLidToCus = criarMapeamentoAutomatico(participants, admins);
        
        // Adicionar detec√ß√£o direta se encontrada
        if (adminDireto) {
            mapeamentoLidToCus[participantId] = 'ADMIN_DIRETO';
            console.log(`‚úÖ Adicionado ${participantId} como ADMIN_DIRETO no mapeamento!`);
        }
        
        // MAPEAMENTO DIRETO POR N√öMERO: Se o participantId for @lid e houver admin @c.us com mesmo n√∫mero
        if (participantId.endsWith('@lid')) {
            const numeroBase = participantId.split('@')[0];
            const adminPorNumero = admins.find(admin => {
                return admin.id._serialized.split('@')[0] === numeroBase;
            });
            
            if (adminPorNumero && !mapeamentoLidToCus[participantId]) {
                mapeamentoLidToCus[participantId] = adminPorNumero.id._serialized;
                // console.log(`üéØ MAPEAMENTO DIRETO: ${participantId} -> ${adminPorNumero.id._serialized}`);
            }
        }
        
        console.log(`üó∫Ô∏è Mapeamento criado:`, mapeamentoLidToCus);
        
        // Salvar cache com mapeamento
        adminCache[chatId] = {
            admins: admins,
            mapeamentoLidToCus: mapeamentoLidToCus,
            timestamp: Date.now()
        };

        // ESTRAT√âGIA FINAL: Se n√£o encontrou o participante na lista, tentar abordagem alternativa
        if (!participanteEspecifico && participantId.endsWith('@lid')) {
            console.log(`üîÑ Tentativa alternativa: Buscando informa√ß√µes sobre ${participantId}...`);
            try {
                // Tentar obter informa√ß√µes do contato diretamente
                const contact = await client.getContactById(participantId);
                console.log(`üìû Info do contato:`, {
                    id: contact.id._serialized,
                    number: contact.number,
                    pushname: contact.pushname,
                    name: contact.name,
                    isUser: contact.isUser
                });
                
                // ESTRAT√âGIA 1: Comparar por n√∫mero real do contato
                if (contact.number) {
                    console.log(`üîç Procurando admin com n√∫mero real: ${contact.number}`);
                    
                    const adminPorNumeroReal = admins.find(admin => {
                        const numeroAdmin = admin.id._serialized.split('@')[0];
                        // Remover c√≥digo de pa√≠s e comparar
                        const numeroLimpoAdmin = numeroAdmin.replace(/^258/, '');
                        const numeroLimpoContato = contact.number.replace(/^258/, '').replace(/^/, '');
                        
                        console.log(`   üîç Comparando "${numeroLimpoContato}" com admin "${numeroLimpoAdmin}"`);
                        return numeroLimpoAdmin === numeroLimpoContato || 
                               numeroAdmin === contact.number ||
                               numeroAdmin.endsWith(contact.number) ||
                               contact.number.endsWith(numeroLimpoAdmin);
                    });
                    
                    if (adminPorNumeroReal) {
                        mapeamentoLidToCus[participantId] = adminPorNumeroReal.id._serialized;
                        console.log(`‚úÖ SUCESSO! Mapeado por n√∫mero real: ${participantId} -> ${adminPorNumeroReal.id._serialized}`);
                    } else {
                        console.log(`‚ùå Nenhum admin encontrado com n√∫mero real ${contact.number}`);
                    }
                }
                
                // ESTRAT√âGIA 2: Comparar com admins por n√∫mero base do ID (fallback)
                if (!mapeamentoLidToCus[participantId]) {
                    const numeroBase = participantId.split('@')[0];
                    console.log(`üîç Fallback - Procurando admin com n√∫mero base: ${numeroBase}`);
                    
                    const adminEncontrado = admins.find(admin => {
                        const numeroAdmin = admin.id._serialized.split('@')[0];
                        console.log(`   üîç Comparando ${numeroBase} com admin ${numeroAdmin}`);
                        return numeroAdmin === numeroBase;
                    });
                    
                    if (adminEncontrado) {
                        mapeamentoLidToCus[participantId] = adminEncontrado.id._serialized;
                        console.log(`‚úÖ SUCESSO! Mapeado por n√∫mero base: ${participantId} -> ${adminEncontrado.id._serialized}`);
                    } else {
                        console.log(`‚ùå Nenhum admin encontrado com n√∫mero ${numeroBase}`);
                        console.log(`üìã Admins dispon√≠veis: ${admins.map(a => a.id._serialized.split('@')[0]).join(', ')}`);
                    }
                }
                
            } catch (err) {
                console.log(`‚ö†Ô∏è Erro ao buscar contato: ${err.message}`);
            }
        }
        
        // Verificar se √© admin usando mapeamento
        const isAdmin = verificarAdminComMapeamento(participantId, admins, mapeamentoLidToCus);
        console.log(`‚úÖ Resultado: ${participantId} √© admin? ${isAdmin}`);
        return isAdmin;
    } catch (error) {
        console.error('‚ùå Erro ao verificar admin do grupo:', error);
        return false;
    }
}

// Criar mapeamento autom√°tico entre IDs @lid e @c.us
function criarMapeamentoAutomatico(participants, admins) {
    const mapeamento = {};
    
    // Para cada participante @lid, tentar encontrar correspond√™ncia com admin @c.us
    const participantesLid = participants.filter(p => p.id._serialized.endsWith('@lid'));
    const adminsIds = admins.map(a => a.id._serialized);
    
    console.log(`üîç Tentando mapear ${participantesLid.length} IDs @lid para ${adminsIds.length} admins @c.us...`);
    
    // Debug detalhado dos participantes
    if (participantesLid.length === 0) {
        console.log(`‚ö†Ô∏è ATEN√á√ÉO: Nenhum participante @lid encontrado!`);
        console.log(`üìã Todos participantes:`, participants.map(p => ({
            id: p.id._serialized,
            isAdmin: p.isAdmin,
            isSuperAdmin: p.isSuperAdmin,
            pushname: p.pushname
        })));
    }
    
    participantesLid.forEach(participante => {
        const lidId = participante.id._serialized;
        console.log(`üîç Analisando ${lidId}: isAdmin=${participante.isAdmin}, isSuperAdmin=${participante.isSuperAdmin}, nome=${participante.pushname}`);
        
        // Estrat√©gia 1: Verificar se o pr√≥prio participante @lid tem flag de admin
        if (participante.isAdmin || participante.isSuperAdmin) {
            console.log(`‚úÖ ${lidId} tem flag de admin direto!`);
            mapeamento[lidId] = 'ADMIN_DIRETO'; // Marcador especial
            return;
        }
        
        // Estrat√©gia 2: Matching por nome (se dispon√≠vel)
        if (participante.pushname) {
            const adminCorrespondente = admins.find(admin => 
                admin.pushname && admin.pushname === participante.pushname
            );
            if (adminCorrespondente) {
                mapeamento[lidId] = adminCorrespondente.id._serialized;
                // console.log(`üéØ Mapeado por nome: ${lidId} -> ${adminCorrespondente.id._serialized}`);
                return;
            } else {
                console.log(`‚ùå Nenhum admin encontrado com nome "${participante.pushname}"`);
            }
        } else {
            console.log(`‚ö†Ô∏è ${lidId} n√£o tem nome dispon√≠vel para matching`);
        }
    });
    
    return mapeamento;
}

// Verificar se √© admin usando o mapeamento
function verificarAdminComMapeamento(participantId, admins, mapeamento) {
    const adminsIds = admins.map(a => a.id._serialized);
    
    // 1. Verifica√ß√£o direta (caso seja @c.us)
    if (adminsIds.includes(participantId)) {
        console.log(`‚úÖ ${participantId} √© admin direto (@c.us)`);
        return true;
    }
    
    // 2. Verifica√ß√£o via mapeamento (caso seja @lid)
    if (mapeamento[participantId]) {
        if (mapeamento[participantId] === 'ADMIN_DIRETO') {
            console.log(`‚úÖ ${participantId} √© admin direto (@lid com flag)`);
            return true;
        } else if (adminsIds.includes(mapeamento[participantId])) {
            console.log(`‚úÖ ${participantId} mapeado para admin ${mapeamento[participantId]}`);
            return true;
        }
    }
    
    console.log(`‚ùå ${participantId} n√£o √© admin`);
    return false;
}

// Fun√ß√£o para verificar se um ID corresponde a um admin
function verificarSeEhAdmin(participantId, admins, todosParticipantes) {
    console.log(`üîç Procurando ${participantId} entre ${admins.length} admins...`);
    
    // 1. Verifica√ß√£o direta por ID
    const adminDireto = admins.find(admin => admin.id._serialized === participantId);
    if (adminDireto) {
        console.log(`‚úÖ Encontrado por ID direto: ${adminDireto.id._serialized}`);
        return true;
    }
    
    // 2. Para IDs @lid, tentar encontrar correspond√™ncia por pushname ou outras caracter√≠sticas
    if (participantId.endsWith('@lid')) {
        console.log(`üîç ${participantId} √© ID @lid, procurando correspond√™ncia...`);
        
        // Buscar o participante pelo ID @lid
        const participante = todosParticipantes.find(p => p.id._serialized === participantId);
        if (participante) {
            console.log(`üì± Participante @lid encontrado:`, {
                id: participante.id._serialized,
                pushname: participante.pushname || 'N/A',
                isAdmin: participante.isAdmin || false,
                isSuperAdmin: participante.isSuperAdmin || false
            });
            
            // VERIFICA√á√ÉO DIRETA: Se o pr√≥prio participante @lid tem flag de admin
            if (participante.isAdmin || participante.isSuperAdmin) {
                console.log(`‚úÖ O pr√≥prio participante @lid TEM flag de admin!`);
                return true;
            }
            
            // Verificar se existe admin com mesmo pushname ou n√∫mero base
            const adminCorrespondente = admins.find(admin => {
                // Tentar matching por pushname se dispon√≠vel
                if (participante.pushname && admin.pushname && 
                    participante.pushname === admin.pushname) {
                    return true;
                }
                return false;
            });
            
            if (adminCorrespondente) {
                console.log(`‚úÖ Encontrado admin correspondente por pushname: ${adminCorrespondente.id._serialized}`);
                return true;
            }
        } else {
            console.log(`‚ùå Participante @lid ${participantId} n√£o encontrado na lista de participantes`);
        }
    }
    
    console.log(`‚ùå ${participantId} n√£o √© admin do grupo`);
    return false;
}

function contemConteudoSuspeito(mensagem) {
    const texto = mensagem.toLowerCase();
    const temLink = /(?:https?:\/\/|www\.|\.com|\.net|\.org|\.br|\.mz|bit\.ly|tinyurl|t\.me|wa\.me|whatsapp\.com|telegram\.me|link|url)/i.test(texto);
    
    return {
        temLink: MODERACAO_CONFIG.detectarLinks && temLink,
        suspeito: MODERACAO_CONFIG.detectarLinks && temLink
    };
}

async function deletarMensagem(message) {
    try {
        await message.delete(true);
        console.log(`üóëÔ∏è Mensagem deletada`);
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao deletar mensagem:', error);
        return false;
    }
}

async function removerParticipante(chatId, participantId, motivo) {
    try {
        const chat = await client.getChatById(chatId);
        await chat.removeParticipants([participantId]);
        console.log(`üö´ Participante removido: ${participantId} - ${motivo}`);
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao remover participante:', error);
        return false;
    }
}

async function aplicarModeracao(message, motivoDeteccao) {
    const chatId = message.from;
    const authorId = message.author || message.from;
    
    try {
        if (!MODERACAO_CONFIG.ativado[chatId]) {
            return;
        }

        if (MODERACAO_CONFIG.excecoes.includes(authorId) || isAdministrador(authorId)) {
            return;
        }

        const isAdmin = await isAdminGrupo(chatId, authorId);
        if (isAdmin) {
            return;
        }

        console.log(`üö® MODERA√á√ÉO: ${motivoDeteccao}`);

        if (MODERACAO_CONFIG.apagarMensagem) {
            await deletarMensagem(message);
        }

        if (MODERACAO_CONFIG.removerUsuario) {
            await removerParticipante(chatId, authorId, motivoDeteccao);
        }

    } catch (error) {
        console.error('‚ùå Erro durante modera√ß√£o:', error);
    }
}

// === DETEC√á√ÉO DE GRUPOS ===
async function logGrupoInfo(chatId, evento = 'detectado') {
    try {
        const chat = await client.getChatById(chatId);
        const isGrupoMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
        
        console.log(`\nüîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        console.log(`üìã GRUPO ${evento.toUpperCase()}`);
        console.log(`üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        console.log(`üìõ Nome: ${chat.name}`);
        console.log(`üÜî ID: ${chatId}`);
        console.log(`üë• Participantes: ${chat.participants ? chat.participants.length : 'N/A'}`);
        console.log(`üìä Monitorado: ${isGrupoMonitorado ? '‚úÖ SIM' : '‚ùå N√ÉO'}`);
        console.log(`‚è∞ Data: ${new Date().toLocaleString('pt-BR')}`);
        
        if (!isGrupoMonitorado) {
            console.log(`\nüîß PARA ADICIONAR ESTE GRUPO:`);
            console.log(`üìù Copie este c√≥digo para CONFIGURACAO_GRUPOS:`);
            console.log(`\n'${chatId}': {`);
            console.log(`    nome: '${chat.name}',`);
            console.log(`    tabela: \`SUA_TABELA_AQUI\`,`);
            console.log(`    pagamento: \`SUAS_FORMAS_DE_PAGAMENTO_AQUI\``);
            console.log(`},\n`);
        }
        
        console.log(`üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
        
        return {
            id: chatId,
            nome: chat.name,
            participantes: chat.participants ? chat.participants.length : 0,
            monitorado: isGrupoMonitorado
        };
        
    } catch (error) {
        console.error(`‚ùå Erro ao obter informa√ß√µes do grupo ${chatId}:`, error);
        return null;
    }
}

// === HIST√ìRICO DE COMPRADORES ===

async function carregarHistorico() {
    try {
        const data = await fs.readFile(ARQUIVO_HISTORICO, 'utf8');
        historicoCompradores = JSON.parse(data);
        console.log('üìä Hist√≥rico carregado!');
    } catch (error) {
        console.log('üìä Criando novo hist√≥rico...');
        historicoCompradores = {};
    }
}

// === SALVAMENTO DE HIST√ìRICO OTIMIZADO ===
let salvamentoHistoricoPendente = false;
let timeoutHistorico = null;

async function salvarHistorico() {
    if (salvamentoHistoricoPendente) return;
    salvamentoHistoricoPendente = true;

    try {
        await fs.writeFile(ARQUIVO_HISTORICO, JSON.stringify(historicoCompradores));
    } catch (error) {
        console.error('‚ùå Erro ao salvar hist√≥rico:', error);
    } finally {
        salvamentoHistoricoPendente = false;
    }
}

function agendarSalvamentoHistorico() {
    if (timeoutHistorico) {
        clearTimeout(timeoutHistorico);
    }

    timeoutHistorico = setTimeout(async () => {
        agendarSalvamentoHistorico();
        timeoutHistorico = null;
    }, 3000); // 3 segundos para hist√≥rico
}

async function registrarComprador(grupoId, numeroComprador, nomeContato, valorTransferencia) {
    const agora = new Date();
    const timestamp = agora.toISOString();

    if (!historicoCompradores[grupoId]) {
        historicoCompradores[grupoId] = {
            nomeGrupo: getConfiguracaoGrupo(grupoId)?.nome || 'Grupo Desconhecido',
            compradores: {}
        };
    }

    if (!historicoCompradores[grupoId].compradores[numeroComprador]) {
        historicoCompradores[grupoId].compradores[numeroComprador] = {
            primeiraCompra: timestamp,
            ultimaCompra: timestamp,
            totalCompras: 1,
            nomeContato: nomeContato,
            historico: []
        };
    } else {
        historicoCompradores[grupoId].compradores[numeroComprador].ultimaCompra = timestamp;
        historicoCompradores[grupoId].compradores[numeroComprador].totalCompras++;
        historicoCompradores[grupoId].compradores[numeroComprador].nomeContato = nomeContato;
    }

    historicoCompradores[grupoId].compradores[numeroComprador].historico.push({
        data: timestamp,
        valor: valorTransferencia
    });

    if (historicoCompradores[grupoId].compradores[numeroComprador].historico.length > 10) {
        historicoCompradores[grupoId].compradores[numeroComprador].historico =
            historicoCompradores[grupoId].compradores[numeroComprador].historico.slice(-10);
    }

    agendarSalvamentoHistorico();
    console.log(`üí∞ Comprador registrado: ${nomeContato} (${numeroComprador}) - ${valorTransferencia}MT`);
}

// === FILA DE MENSAGENS ===

function adicionarNaFila(mensagem, autor, nomeGrupo, timestamp) {
    const item = {
        conteudo: mensagem,
        autor: autor,
        grupo: nomeGrupo,
        timestamp: timestamp,
        id: Date.now() + Math.random()
    };

    filaMensagens.push(item);
    console.log(`üì• Adicionado √† fila: ${filaMensagens.length} mensagens`);

    if (!processandoFila) {
        processarFila();
    }
}

async function processarFila() {
    if (processandoFila || filaMensagens.length === 0) {
        return;
    }

    processandoFila = true;
    console.log(`üöÄ Processando ${filaMensagens.length} mensagens...`);

    while (filaMensagens.length > 0) {
        const item = filaMensagens.shift();

        try {
            await client.sendMessage(ENCAMINHAMENTO_CONFIG.numeroDestino, item.conteudo);
            console.log(`‚úÖ Encaminhado: ${item.conteudo.substring(0, 50)}...`);

            if (filaMensagens.length > 0) {
                await new Promise(resolve => setTimeout(resolve, ENCAMINHAMENTO_CONFIG.intervaloSegundos * 1000));
            }

        } catch (error) {
            console.error(`‚ùå Erro ao encaminhar:`, error);
            filaMensagens.unshift(item);
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
    }

    processandoFila = false;
    console.log(`üéâ Fila processada!`);
}

// === EVENTOS DO BOT ===

client.on('qr', (qr) => {
    console.log('üì± QR Code gerado - Escaneie o QR Code:');
    qrcode.generate(qr, { small: true });
});

client.on('authenticated', () => {
    console.log('üîê Cliente autenticado com sucesso!');
});

client.on('auth_failure', (msg) => {
    console.error('‚ùå Falha na autentica√ß√£o:', msg);
});

client.on('loading_screen', (percent, message) => {
    console.log('‚è≥ Carregando WhatsApp...', percent + '%', message);
});

client.on('ready', async () => {
    console.log('‚úÖ Bot conectado e pronto!');
    console.log('üß† IA WhatsApp ativa!');
    console.log('üìä Google Sheets configurado!');
    console.log(`üîó URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}`);
    console.log('ü§ñ Bot Retalho - L√≥gica simples igual ao Bot Atacado!');
    
    // === INICIALIZAR SISTEMA DE PACOTES AP√ìS WhatsApp CONECTAR ===
    if (process.env.SISTEMA_PACOTES_ENABLED === 'true') {
        sistemaPacotes = new SistemaPacotes();
        console.log('üì¶ Sistema de Pacotes Autom√°ticos ATIVADO');
    } else {
        console.log('üì¶ Sistema de Pacotes Autom√°ticos DESABILITADO (.env)');
    }
    
    // === INICIALIZAR SISTEMA DE COMPRAS ===
    sistemaCompras = new SistemaCompras();
    console.log('üõí Sistema de Registro de Compras ATIVADO');
    
    // Carregar dados de refer√™ncia
    await carregarDadosReferencia();
    
    await carregarHistorico();
    
    console.log('\nü§ñ Monitorando grupos:');
    Object.keys(CONFIGURACAO_GRUPOS).forEach(grupoId => {
        const config = CONFIGURACAO_GRUPOS[grupoId];
        console.log(`   üìã ${config.nome} (${grupoId})`);
    });
    
    console.log('\nüîß Comandos admin: .ia .stats .sheets .test_sheets .test_grupo .grupos_status .grupos .grupo_atual .addcomando .comandos .delcomando .test_vision .ranking .inativos .semcompra .resetranking .bonus .setboasvindas .getboasvindas .testboasvindas');
    
    // Iniciar monitoramento autom√°tico de novos membros
    await iniciarMonitoramentoMembros();
});

client.on('group-join', async (notification) => {
    try {
        const chatId = notification.chatId;
        const addedParticipants = notification.recipientIds || [];
        const botInfo = client.info;
        
        if (botInfo && addedParticipants.includes(botInfo.wid._serialized)) {
            console.log(`\nü§ñ BOT ADICIONADO A UM NOVO GRUPO!`);
            await logGrupoInfo(chatId, 'BOT ADICIONADO');
            
            setTimeout(async () => {
                try {
                    const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
                    const mensagem = isMonitorado ? 
                        `ü§ñ *BOT ATIVO E CONFIGURADO!*\n\nEste grupo est√° monitorado e o sistema autom√°tico j√° est√° funcionando.\n\nüìã Digite: *tabela* (ver pre√ßos)\nüí≥ Digite: *pagamento* (ver formas)` :
                        `ü§ñ *BOT CONECTADO!*\n\n‚öôÔ∏è Este grupo ainda n√£o est√° configurado.\nüîß Contacte o administrador para ativa√ß√£o.\n\nüìù ID do grupo copiado no console do servidor.`;
                    
                    await client.sendMessage(chatId, mensagem);
                    console.log(`‚úÖ Mensagem de status enviada`);
                } catch (error) {
                    console.error('‚ùå Erro ao enviar mensagem de status:', error);
                }
            }, 3000);
        } else {
            // NOVOS MEMBROS (N√ÉO-BOT) ENTRARAM NO GRUPO
            const configGrupo = getConfiguracaoGrupo(chatId);
            
            if (configGrupo) {
                // Processar cada novo membro
                for (const participantId of addedParticipants) {
                    try {
                        console.log(`üëã Novo membro: ${participantId} em ${configGrupo.nome}`);
                        
                        // Aguardar um pouco para evitar spam
                        setTimeout(async () => {
                            try {
                                await enviarBoasVindas(chatId, participantId);
                            } catch (error) {
                                console.error(`‚ùå Erro ao enviar boas-vindas para ${participantId}:`, error);
                            }
                        }, 2000 + (Math.random() * 3000));
                        
                    } catch (error) {
                        console.error(`‚ùå Erro ao processar novo membro ${participantId}:`, error);
                    }
                }
            }
        }
    } catch (error) {
        console.error('‚ùå Erro no evento group-join:', error);
    }
});

client.on('message', async (message) => {
    try {
        const isPrivado = !message.from.endsWith('@g.us');
        const autorMensagem = message.author || message.from;
        const isAdmin = isAdministrador(autorMensagem);
        
        // DEBUG DETALHADO DA MENSAGEM
        if (message.body.startsWith('.addcomando') || message.body.startsWith('.comandos') || message.body.startsWith('.delcomando')) {
            console.log(`üîç DEBUG MENSAGEM ADMIN:`);
            console.log(`   üì± message.from: ${message.from}`);
            console.log(`   üë§ message.author: ${message.author}`);
            console.log(`   üÜî autorMensagem: ${autorMensagem}`);
            
            try {
                const contact = await message.getContact();
                console.log(`   üìû Contact info:`, {
                    id: contact.id._serialized,
                    number: contact.number,
                    pushname: contact.pushname,
                    name: contact.name,
                    isMyContact: contact.isMyContact
                });
            } catch (err) {
                console.log(`   ‚ö†Ô∏è Erro ao obter contato: ${err.message}`);
            }
        }
        
        console.log(`üîç Debug: Verificando admin para ${autorMensagem}, resultado: ${isAdmin}`);

        // === COMANDOS ADMINISTRATIVOS ===
        // Verificar se √© admin global OU admin do grupo
        let isAdminDoGrupo = false;
        
        // S√≥ verificar admin do grupo se for mensagem de grupo
        if (message.from.endsWith('@g.us')) {
            isAdminDoGrupo = await isAdminGrupo(message.from, autorMensagem);
            console.log(`üîç Debug admin grupo: ${autorMensagem} √© admin do grupo? ${isAdminDoGrupo}`);
        }
        
        const isAdminQualquer = isAdmin || isAdminDoGrupo;
        console.log(`üîç Debug final: isAdminQualquer = ${isAdminQualquer} (global: ${isAdmin}, grupo: ${isAdminDoGrupo})`);
        
        if (isAdminQualquer) {
            const comando = message.body.toLowerCase().trim();

            if (comando === '.ia') {
                const statusIA = ia.getStatusDetalhado();
                await message.reply(statusIA);
                console.log(`üß† Comando .ia executado`);
                return;
            }

            if (comando === '.stats') {
                let stats = `üìä *ESTAT√çSTICAS*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                Object.keys(CONFIGURACAO_GRUPOS).forEach(grupoId => {
                    const config = CONFIGURACAO_GRUPOS[grupoId];
                    const dados = historicoCompradores[grupoId];
                    const totalCompradores = dados ? Object.keys(dados.compradores || {}).length : 0;
                    
                    if (totalCompradores > 0) {
                        stats += `üè¢ *${config.nome}*\n`;
                        stats += `üë• ${totalCompradores} compradores\n\n`;
                    }
                });
                
                await message.reply(stats);
                return;
            }

            if (comando === '.bonus_stats') {
                let stats = `üéÅ *ESTAT√çSTICAS DO SISTEMA DE REFER√äNCIAS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                // Estat√≠sticas gerais
                const totalCodigos = Object.keys(codigosReferencia).length;
                const totalReferencias = Object.keys(referenciasClientes).length;
                const totalUsuariosComBonus = Object.keys(bonusSaldos).length;
                const totalSaques = Object.keys(pedidosSaque).length;
                
                stats += `üìä **RESUMO GERAL:**\n`;
                stats += `   ‚Ä¢ C√≥digos gerados: ${totalCodigos}\n`;
                stats += `   ‚Ä¢ Refer√™ncias ativas: ${totalReferencias}\n`;
                stats += `   ‚Ä¢ Usu√°rios com b√¥nus: ${totalUsuariosComBonus}\n`;
                stats += `   ‚Ä¢ Saques solicitados: ${totalSaques}\n\n`;
                
                // Top convidadores
                const topConvidadores = Object.values(bonusSaldos)
                    .map(dados => ({
                        saldo: dados.saldo,
                        referencias: Object.keys(dados.detalhesReferencias || {}).length,
                        dados: dados
                    }))
                    .sort((a, b) => b.saldo - a.saldo)
                    .slice(0, 5);
                
                if (topConvidadores.length > 0) {
                    stats += `üèÜ **TOP 5 CONVIDADORES:**\n`;
                    topConvidadores.forEach((item, index) => {
                        const saldoGB = (item.saldo / 1024).toFixed(2);
                        stats += `   ${index + 1}. ${item.saldo}MB (${saldoGB}GB) - ${item.referencias} refer√™ncias\n`;
                    });
                    stats += `\n`;
                }
                
                // Estat√≠sticas de compras
                let totalComprasBonus = 0;
                let totalBonusDistribuido = 0;
                
                Object.values(bonusSaldos).forEach(saldo => {
                    if (saldo.detalhesReferencias) {
                        Object.values(saldo.detalhesReferencias).forEach(ref => {
                            totalComprasBonus += ref.compras || 0;
                            totalBonusDistribuido += ref.bonusGanho || 0;
                        });
                    }
                });
                
                stats += `üí∞ **B√îNUS DISTRIBU√çDOS:**\n`;
                stats += `   ‚Ä¢ Total de compras que geraram b√¥nus: ${totalComprasBonus}\n`;
                stats += `   ‚Ä¢ Total de MB distribu√≠dos: ${totalBonusDistribuido}MB\n`;
                stats += `   ‚Ä¢ Equivalente em GB: ${(totalBonusDistribuido / 1024).toFixed(2)}GB\n\n`;
                
                // Saques pendentes
                const saquesPendentes = Object.values(pedidosSaque).filter(p => p.status === 'pendente');
                if (saquesPendentes.length > 0) {
                    stats += `‚è≥ **SAQUES PENDENTES:** ${saquesPendentes.length}\n`;
                    const totalPendente = saquesPendentes.reduce((sum, p) => sum + p.quantidade, 0);
                    stats += `   ‚Ä¢ Valor total: ${totalPendente}MB (${(totalPendente/1024).toFixed(2)}GB)\n\n`;
                }
                
                stats += `üìà **SISTEMA DE REFER√äNCIAS ATIVO E FUNCIONANDO!**`;
                
                await message.reply(stats);
                return;
            }

            // === COMANDOS DO SISTEMA DE PACOTES ===
            if (sistemaPacotes) {
                
                // .pacote DIAS REF NUMERO - Criar pacote
                if (comando.startsWith('.pacote ')) {
                    console.log(`üîß DEBUG: Comando .pacote detectado!`);
                    console.log(`üîß DEBUG: sistemaPacotes = ${sistemaPacotes ? 'INICIALIZADO' : 'NULL'}`);
                    console.log(`üîß DEBUG: SISTEMA_PACOTES_ENABLED = ${process.env.SISTEMA_PACOTES_ENABLED}`);
                    
                    if (!sistemaPacotes) {
                        await message.reply(`‚ùå *SISTEMA DE PACOTES DESABILITADO*\n\nO sistema de pacotes autom√°ticos n√£o est√° ativo neste servidor.\n\nVerifique as configura√ß√µes de ambiente.`);
                        return;
                    }
                    const partes = message.body.trim().split(' ');
                    
                    if (partes.length < 4) {
                        await message.reply(`‚ùå *USO INCORRETO*\n\n‚úÖ **Formato correto:**\n*.pacote DIAS REF NUMERO*\n\nüìù **Exemplos:**\n‚Ä¢ *.pacote 3 ABC123 845123456*\n‚Ä¢ *.pacote 30 XYZ789 847654321*\n\nüì¶ **Tipos dispon√≠veis:**\n‚Ä¢ 3 - Pacote de 3 dias (300MB)\n‚Ä¢ 5 - Pacote de 5 dias (500MB)\n‚Ä¢ 15 - Pacote de 15 dias (1.5GB)\n‚Ä¢ 30 - Pacote de 30 dias (3GB)`);
                        return;
                    }
                    
                    const [, diasPacote, referencia, numero] = partes;
                    const grupoId = message.from;
                    
                    console.log(`üì¶ COMANDO PACOTE: Dias=${diasPacote}, Ref=${referencia}, Numero=${numero}`);
                    
                    const resultado = await sistemaPacotes.processarComprovante(referencia, numero, grupoId, diasPacote);
                    
                    if (resultado.sucesso) {
                        await message.reply(resultado.mensagem);
                    } else {
                        await message.reply(`‚ùå **ERRO AO CRIAR PACOTE**\n\n‚ö†Ô∏è ${resultado.erro}\n\nüí° **Verificar:**\n‚Ä¢ Dias v√°lidos (3, 5, 15, 30)\n‚Ä¢ Refer√™ncia n√£o est√° duplicada`);
                    }
                    return;
                }
                
                // .pacotes_ativos - Listar clientes com pacotes ativos (do grupo atual)
                if (comando === '.pacotes_ativos') {
                    const lista = sistemaPacotes.listarClientesAtivos(message.from);
                    await message.reply(lista);
                    return;
                }
                
                // .pacotes_stats - Estat√≠sticas do sistema de pacotes
                if (comando === '.pacotes_stats') {
                    const stats = sistemaPacotes.obterEstatisticas();
                    await message.reply(stats);
                    return;
                }

                // .pacotes_todos - Listar pacotes de TODOS os grupos (apenas admins globais)
                if (comando === '.pacotes_todos') {
                    if (!isAdministrador(autorMensagem)) {
                        await message.reply('‚ùå *Acesso negado!* Apenas administradores globais podem ver pacotes de todos os grupos.');
                        return;
                    }
                    const lista = sistemaPacotes.listarClientesAtivos(null); // null = todos os grupos
                    await message.reply(lista);
                    return;
                }
                
                // .cancelar_pacote NUMERO REF - Cancelar pacote
                if (comando.startsWith('.cancelar_pacote ')) {
                    const partes = message.body.trim().split(' ');
                    
                    if (partes.length < 3) {
                        await message.reply(`‚ùå *USO INCORRETO*\n\n‚úÖ **Formato correto:**\n*.cancelar_pacote NUMERO REFERENCIA*\n\nüìù **Exemplo:**\n‚Ä¢ *.cancelar_pacote 845123456 ABC123*`);
                        return;
                    }
                    
                    const [, numero, referencia] = partes;
                    const resultado = sistemaPacotes.cancelarPacote(numero, referencia);
                    await message.reply(resultado);
                    return;
                }

                // .validade NUMERO - Verificar validade do pacote (comando para CLIENTES)
                if (comando.startsWith('.validade ')) {
                    const partes = message.body.trim().split(' ');
                    
                    if (partes.length < 2) {
                        await message.reply(`‚ùå *USO INCORRETO*\n\n‚úÖ **Formato correto:**\n*.validade NUMERO*\n\nüìù **Exemplo:**\n‚Ä¢ *.validade 845123456*\n\nüí° Digite seu n√∫mero para verificar a validade do seu pacote de 100MB di√°rios.`);
                        return;
                    }
                    
                    const numero = partes[1];
                    const resultado = sistemaPacotes.verificarValidadePacote(numero);
                    
                    await message.reply(resultado);
                    return;
                }
                
                // .sistema_pacotes - Status do sistema
                if (comando === '.sistema_pacotes') {
                    const status = sistemaPacotes.getStatus();
                    let resposta = `üì¶ *STATUS DO SISTEMA DE PACOTES*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                    resposta += `üü¢ **Status:** ${status.ativo ? 'ATIVO' : 'INATIVO'}\n`;
                    resposta += `üë• **Clientes ativos:** ${status.clientesAtivos}\n`;
                    resposta += `‚è±Ô∏è **Verifica√ß√£o:** ${status.intervalVerificacao/60000} min\n`;
                    resposta += `üì¶ **Tipos dispon√≠veis:** ${status.tiposPacotes.join(', ')}\n`;
                    resposta += `üìä **Hist√≥rico:** ${status.historicoSize} registros\n\n`;
                    resposta += `üîß **Comandos Administrativos:**\n`;
                    resposta += `‚Ä¢ *.pacote DIAS REF NUMERO* - Criar pacote\n`;
                    resposta += `‚Ä¢ *.pacotes_ativos* - Listar ativos\n`;
                    resposta += `‚Ä¢ *.pacotes_stats* - Estat√≠sticas\n`;
                    resposta += `‚Ä¢ *.cancelar_pacote NUMERO REF* - Cancelar\n\n`;
                    resposta += `üë§ **Comando para Clientes:**\n`;
                    resposta += `‚Ä¢ *.validade NUMERO* - Verificar validade do pacote\n\n`;
                    resposta += `‚ö° *Sistema funcionando automaticamente!*`;
                    
                    await message.reply(resposta);
                    return;
                }
            }

            // === COMANDOS DO SISTEMA DE COMPRAS ===
            if (sistemaCompras) {
                // .ranking - Mostrar ranking completo de compradores
                if (comando === '.ranking') {
                    try {
                        const ranking = await sistemaCompras.obterRankingCompletoGrupo(message.from);
                        
                        if (ranking.length === 0) {
                            await message.reply(`üìä *RANKING DE COMPRADORES*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nüö´ Nenhum comprador registrado hoje.`);
                            return;
                        }
                        
                        let mensagem = `üìä *RANKING DE COMPRADORES*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                        let mentions = [];
                        
                        for (let i = 0; i < ranking.length; i++) {
                            const item = ranking[i];
                            const contactId = item.numero + '@c.us';
                            
                            // Obter informa√ß√µes do contato
                            try {
                                const contact = await client.getContactById(contactId);
                                
                                // Prioridade: nome salvo > nome do perfil > n√∫mero
                                const nomeExibicao = contact.name || contact.pushname || item.numero;
                                const numeroLimpo = contact.id.user; // N√∫mero sem @ e sem +
                                
                                const posicaoEmoji = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${item.posicao}¬∫`;
                                const megasFormatados = item.megas >= 1024 ? 
                                    `${(item.megas/1024).toFixed(1)}GB` : `${item.megas}MB`;
                                
                                mensagem += `${posicaoEmoji} @${numeroLimpo}\n`;
                                mensagem += `   üíæ ${megasFormatados} no grupo (${item.compras}x)\n`;
                                mensagem += `   üìä Total: ${item.megasTotal >= 1024 ? (item.megasTotal/1024).toFixed(1)+'GB' : item.megasTotal+'MB'}\n\n`;
                                
                                mentions.push(contactId);
                            } catch (error) {
                                // Se n√£o conseguir obter o contato, usar apenas o n√∫mero
                                const posicaoEmoji = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${item.posicao}¬∫`;
                                const megasFormatados = item.megas >= 1024 ? 
                                    `${(item.megas/1024).toFixed(1)}GB` : `${item.megas}MB`;
                                
                                mensagem += `${posicaoEmoji} @${item.numero}\n`;
                                mensagem += `   üíæ ${megasFormatados} no grupo (${item.compras}x)\n`;
                                mensagem += `   üìä Total: ${item.megasTotal >= 1024 ? (item.megasTotal/1024).toFixed(1)+'GB' : item.megasTotal+'MB'}\n\n`;
                                
                                mentions.push(contactId);
                            }
                        }
                        
                        mensagem += `üèÜ *Total de compradores no grupo: ${ranking.length}*`;
                        
                        await client.sendMessage(message.from, mensagem, { mentions: mentions });
                        return;
                    } catch (error) {
                        console.error('‚ùå Erro ao obter ranking:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel obter o ranking de compradores.\n\n‚ö†Ô∏è Erro: ${error.message}`);
                        return;
                    }
                }
                
                // .inativos - Mostrar compradores inativos (mais de 10 dias sem comprar)
                if (comando === '.inativos') {
                    try {
                        const inativos = await sistemaCompras.obterInativos();
                        
                        if (inativos.length === 0) {
                            await message.reply(`üò¥ *COMPRADORES INATIVOS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nüéâ Todos os compradores est√£o ativos!\nNingu√©m est√° h√° mais de 10 dias sem comprar.`);
                            return;
                        }
                        
                        let mensagem = `üò¥ *COMPRADORES INATIVOS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                        mensagem += `‚è∞ Mais de 10 dias sem comprar\n\n`;
                        let mentions = [];
                        
                        for (let i = 0; i < Math.min(inativos.length, 20); i++) {
                            const item = inativos[i];
                            const contactId = item.numero + '@c.us';
                            
                            // Obter informa√ß√µes do contato
                            try {
                                const contact = await client.getContactById(contactId);
                                
                                // Prioridade: nome salvo > nome do perfil > n√∫mero
                                const nomeExibicao = contact.name || contact.pushname || item.numero;
                                const numeroLimpo = contact.id.user; // N√∫mero sem @ e sem +
                                
                                const totalFormatado = item.megasTotal >= 1024 ? 
                                    `${(item.megasTotal/1024).toFixed(1)}GB` : `${item.megasTotal}MB`;
                                
                                mensagem += `üë§ @${numeroLimpo}\n`;
                                mensagem += `   ‚è∞ ${item.diasSemComprar} dias sem comprar\n`;
                                mensagem += `   üìä Total: ${item.totalCompras}x compras (${totalFormatado})\n\n`;
                                
                                mentions.push(contactId);
                            } catch (error) {
                                // Se n√£o conseguir obter o contato, usar apenas o n√∫mero
                                const totalFormatado = item.megasTotal >= 1024 ? 
                                    `${(item.megasTotal/1024).toFixed(1)}GB` : `${item.megasTotal}MB`;
                                
                                mensagem += `üë§ @${item.numero}\n`;
                                mensagem += `   ‚è∞ ${item.diasSemComprar} dias sem comprar\n`;
                                mensagem += `   üìä Total: ${item.totalCompras}x compras (${totalFormatado})\n\n`;
                                
                                mentions.push(contactId);
                            }
                        }
                        
                        if (inativos.length > 20) {
                            mensagem += `... e mais ${inativos.length - 20} compradores inativos\n\n`;
                        }
                        
                        mensagem += `üò¥ *Total de inativos: ${inativos.length}*`;
                        
                        await client.sendMessage(message.from, mensagem, { mentions: mentions });
                        return;
                    } catch (error) {
                        console.error('‚ùå Erro ao obter inativos:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel obter a lista de inativos.\n\n‚ö†Ô∏è Erro: ${error.message}`);
                        return;
                    }
                }
                
                // .semcompra - Mostrar usu√°rios que nunca compraram
                if (comando === '.semcompra') {
                    try {
                        const semCompra = await sistemaCompras.obterSemCompra();
                        
                        if (semCompra.length === 0) {
                            await message.reply(`üÜï *USU√ÅRIOS SEM COMPRAS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ú® Todos os usu√°rios registrados j√° fizeram pelo menos uma compra!`);
                            return;
                        }
                        
                        let mensagem = `üÜï *USU√ÅRIOS SEM COMPRAS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                        mensagem += `üë• Nunca fizeram compras\n\n`;
                        let mentions = [];
                        
                        for (let i = 0; i < Math.min(semCompra.length, 30); i++) {
                            const item = semCompra[i];
                            const contactId = item.numero + '@c.us';
                            
                            // Obter informa√ß√µes do contato
                            try {
                                const contact = await client.getContactById(contactId);
                                
                                // Prioridade: nome salvo > nome do perfil > n√∫mero
                                const nomeExibicao = contact.name || contact.pushname || item.numero;
                                const numeroLimpo = contact.id.user; // N√∫mero sem @ e sem +
                                
                                mensagem += `üë§ @${numeroLimpo}\n`;
                                mensagem += `   üìÖ Registrado: ${new Date(item.primeiraCompra).toLocaleDateString('pt-BR')}\n`;
                                mensagem += `   üí∞ Compras: ${item.totalCompras} (${item.megasTotal}MB)\n\n`;
                                
                                mentions.push(contactId);
                            } catch (error) {
                                // Se n√£o conseguir obter o contato, usar apenas o n√∫mero
                                mensagem += `üë§ @${item.numero}\n`;
                                mensagem += `   üìÖ Registrado: ${new Date(item.primeiraCompra).toLocaleDateString('pt-BR')}\n`;
                                mensagem += `   üí∞ Compras: ${item.totalCompras} (${item.megasTotal}MB)\n\n`;
                                
                                mentions.push(contactId);
                            }
                        }
                        
                        if (semCompra.length > 30) {
                            mensagem += `... e mais ${semCompra.length - 30} usu√°rios sem compras\n\n`;
                        }
                        
                        mensagem += `üÜï *Total sem compras: ${semCompra.length}*\n\n`;
                        mensagem += `üí° *Dica:* Considere campanhas de incentivo para estes usu√°rios!`;
                        
                        await client.sendMessage(message.from, mensagem, { mentions: mentions });
                        return;
                    } catch (error) {
                        console.error('‚ùå Erro ao obter sem compra:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel obter a lista de usu√°rios sem compras.\n\n‚ö†Ô∏è Erro: ${error.message}`);
                        return;
                    }
                }

                // .resetranking - Reset manual do ranking di√°rio (ADMIN APENAS)
                if (comando === '.resetranking') {
                    try {
                        // Verificar permiss√£o de admin
                        const admins = ['258861645968', '258123456789', '258852118624']; // Lista de admins
                        if (!admins.includes(remetente)) {
                            return; // Falha silenciosa para seguran√ßa
                        }

                        console.log(`üîÑ RESET: Admin ${remetente} solicitou reset do ranking di√°rio`);

                        // Executar reset atrav√©s do sistema de compras
                        const resultado = await sistemaCompras.resetarRankingGrupo(message.from);

                        if (resultado.success) {
                            let resposta = `üîÑ *RANKING RESETADO*\n\n`;
                            resposta += `‚úÖ *Status:* ${resultado.message}\n`;
                            resposta += `üë• *Clientes afetados:* ${resultado.clientesResetados}\n`;
                            resposta += `üìÖ *Data do reset:* ${new Date(resultado.dataReset).toLocaleString('pt-BR')}\n`;
                            resposta += `üëë *Executado por:* Administrador\n\n`;
                            resposta += `üí° *Pr√≥ximos passos:*\n`;
                            resposta += `‚Ä¢ Use .ranking para verificar novo estado\n`;
                            resposta += `‚Ä¢ Novos comprovantes come√ßar√£o nova contagem`;

                            await message.reply(resposta);
                        } else {
                            await message.reply(`‚ùå *ERRO NO RESET*\n\n‚ö†Ô∏è ${resultado.message}\n\nüí° Contate o suporte t√©cnico se o problema persistir`);
                        }

                    } catch (error) {
                        console.error('‚ùå Erro no comando .resetranking:', error);
                        await message.reply(`‚ùå *ERRO INTERNO*\n\n‚ö†Ô∏è N√£o foi poss√≠vel resetar o ranking\n\nüìù Erro: ${error.message}`);
                    }
                    return;
                }
                
                // .setboasvindas - Definir mensagem de boas-vindas personalizada (ADMIN APENAS)
                if (comando.startsWith('.setboasvindas ')) {
                    if (!isAdmin) {
                        await message.reply('‚ùå Apenas administradores podem usar este comando!');
                        return;
                    }
                    
                    try {
                        // Extrair a nova mensagem
                        const novaMensagem = message.body.substring('.setboasvindas '.length).trim();
                        
                        if (novaMensagem.length === 0) {
                            await message.reply(`‚ùå *ERRO*\n\nUso: .setboasvindas [mensagem]\n\nüìù *Placeholder dispon√≠vel:*\n@NOME - ser√° substitu√≠do pelo nome do novo membro\n\n*Exemplo:*\n.setboasvindas üéâ Bem-vindo @NOME! Nosso sistema √© 100% autom√°tico!`);
                            return;
                        }
                        
                        if (novaMensagem.length > 2000) {
                            await message.reply(`‚ùå *MENSAGEM MUITO LONGA*\n\nM√°ximo: 2000 caracteres\nAtual: ${novaMensagem.length} caracteres`);
                            return;
                        }
                        
                        // Salvar no arquivo (simula√ß√£o - na pr√°tica voc√™ salvaria em BD)
                        console.log(`üîß ADMIN ${remetente} definiu nova mensagem de boas-vindas para grupo ${message.from}`);
                        
                        const resposta = `‚úÖ *MENSAGEM DE BOAS-VINDAS ATUALIZADA*\n\n` +
                                        `üë§ *Admin:* ${message._data.notifyName || 'Admin'}\n` +
                                        `üì± *Grupo:* ${message.from}\n` +
                                        `üìù *Caracteres:* ${novaMensagem.length}/2000\n\n` +
                                        `üìã *Pr√©via da mensagem:*\n` +
                                        `${novaMensagem.substring(0, 200)}${novaMensagem.length > 200 ? '...' : ''}\n\n` +
                                        `‚úÖ A nova mensagem ser√° usada para pr√≥ximos membros!\n` +
                                        `üí° Use .testboasvindas para testar`;
                        
                        await message.reply(resposta);
                        
                    } catch (error) {
                        console.error('‚ùå Erro no comando .setboasvindas:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel atualizar a mensagem\n\nüìù Erro: ${error.message}`);
                    }
                    return;
                }
                
                // .getboasvindas - Ver mensagem atual de boas-vindas (ADMIN APENAS)
                if (comando === '.getboasvindas') {
                    if (!isAdmin) {
                        await message.reply('‚ùå Apenas administradores podem usar este comando!');
                        return;
                    }
                    
                    try {
                        const configGrupo = getConfiguracaoGrupo(message.from);
                        if (!configGrupo) {
                            await message.reply('‚ùå Este grupo n√£o est√° configurado!');
                            return;
                        }
                        
                        const mensagemAtual = configGrupo.boasVindas || 'Mensagem padr√£o (n√£o personalizada)';
                        
                        const resposta = `üìã *MENSAGEM DE BOAS-VINDAS ATUAL*\n\n` +
                                        `üì± *Grupo:* ${configGrupo.nome}\n` +
                                        `üìù *Caracteres:* ${mensagemAtual.length}/2000\n\n` +
                                        `üìã *Mensagem:*\n${mensagemAtual}\n\n` +
                                        `üí° Use .setboasvindas para alterar\n` +
                                        `üß™ Use .testboasvindas para testar`;
                        
                        await message.reply(resposta);
                        
                    } catch (error) {
                        console.error('‚ùå Erro no comando .getboasvindas:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel obter a mensagem\n\nüìù Erro: ${error.message}`);
                    }
                    return;
                }
                
                // .testboasvindas - Testar mensagem de boas-vindas (ADMIN APENAS)  
                if (comando === '.testboasvindas') {
                    if (!isAdmin) {
                        await message.reply('‚ùå Apenas administradores podem usar este comando!');
                        return;
                    }
                    
                    try {
                        await message.reply('üß™ *TESTE DE BOAS-VINDAS*\n\nEnviando mensagem de teste...');
                        
                        // Enviar boas-vindas para o pr√≥prio admin como teste
                        setTimeout(async () => {
                            await enviarBoasVindas(message.from, autorMensagem);
                        }, 1000);
                        
                    } catch (error) {
                        console.error('‚ùå Erro no comando .testboasvindas:', error);
                        await message.reply(`‚ùå *ERRO*\n\nN√£o foi poss√≠vel testar a mensagem\n\nüìù Erro: ${error.message}`);
                    }
                    return;
                }
                
                // .bonus NUMERO QUANTIDADE - Dar b√¥nus manual (ADMIN APENAS)
                if (comando.startsWith('.bonus ')) {
                    try {
                        console.log(`üîç Debug .bonus: autorMensagem = ${autorMensagem}`);
                        // Verificar permiss√£o de admin
                        const admins = ['258861645968', '258123456789', '258852118624']; // Lista de admins
                        const numeroAdmin = autorMensagem.replace('@c.us', '');
                        if (!admins.includes(numeroAdmin)) {
                            console.log(`‚ùå Admin n√£o autorizado: ${autorMensagem} (${numeroAdmin})`);
                            return; // Falha silenciosa para seguran√ßa
                        }

                        const parametros = comando.split(' ');
                        if (parametros.length < 3) {
                            await message.reply(`‚ùå *FORMATO INCORRETO*\n\n‚úÖ Use: *.bonus @usuario QUANTIDADE* ou *.bonus NUMERO QUANTIDADE*\nExemplos:\n‚Ä¢ *.bonus @258123456789 500MB*\n‚Ä¢ *.bonus 258123456789 500MB*`);
                            return;
                        }

                        let numeroDestino = parametros[1];
                        const quantidadeStr = parametros[2].toUpperCase();

                        // Verificar se √© men√ß√£o ou n√∫mero direto
                        if (numeroDestino.startsWith('@')) {
                            // Remover @ e verificar se tem men√ß√µes na mensagem
                            const numeroMencao = numeroDestino.substring(1);
                            if (message.mentionedIds && message.mentionedIds.length > 0) {
                                // Usar a primeira men√ß√£o encontrada
                                const mencaoId = message.mentionedIds[0];
                                numeroDestino = mencaoId.replace('@c.us', '');
                            } else {
                                // Tentar usar o n√∫mero ap√≥s @
                                numeroDestino = numeroMencao;
                            }
                        }

                        // Validar n√∫mero - aceitar 9 d√≠gitos (848715208) ou 12 d√≠gitos (258848715208)
                        if (!/^\d{9}$/.test(numeroDestino) && !/^\d{12}$/.test(numeroDestino)) {
                            await message.reply(`‚ùå *N√öMERO INV√ÅLIDO*\n\n‚úÖ Use formato:\n‚Ä¢ *.bonus @848715208 500MB* (9 d√≠gitos)\n‚Ä¢ *.bonus @258848715208 500MB* (12 d√≠gitos)\n‚Ä¢ *.bonus 848715208 500MB* (n√∫mero direto)`);
                            return;
                        }
                        
                        // Converter para formato completo se necess√°rio (adicionar 258 no in√≠cio)
                        if (numeroDestino.length === 9) {
                            numeroDestino = '258' + numeroDestino;
                        }

                        // Converter quantidade para MB
                        let quantidadeMB;
                        if (quantidadeStr.endsWith('GB')) {
                            const gb = parseFloat(quantidadeStr.replace('GB', ''));
                            if (isNaN(gb) || gb <= 0) {
                                await message.reply(`‚ùå Quantidade inv√°lida: *${quantidadeStr}*`);
                                return;
                            }
                            quantidadeMB = Math.round(gb * 1024);
                        } else if (quantidadeStr.endsWith('MB')) {
                            quantidadeMB = parseInt(quantidadeStr.replace('MB', ''));
                            if (isNaN(quantidadeMB) || quantidadeMB <= 0) {
                                await message.reply(`‚ùå Quantidade inv√°lida: *${quantidadeStr}*`);
                                return;
                            }
                        } else {
                            await message.reply(`‚ùå *FORMATO INV√ÅLIDO*\n\n‚úÖ Use: MB ou GB\nExemplos: 500MB, 1.5GB, 2GB`);
                            return;
                        }

                        const participantId = numeroDestino + '@c.us';
                        
                        // Inicializar saldo se n√£o existir
                        if (!bonusSaldos[participantId]) {
                            bonusSaldos[participantId] = {
                                saldo: 0,
                                detalhesReferencias: {},
                                historicoSaques: [],
                                totalReferencias: 0,
                                bonusAdmin: []
                            };
                        }

                        // Adicionar b√¥nus
                        bonusSaldos[participantId].saldo += quantidadeMB;
                        
                        // Registrar hist√≥rico de b√¥nus admin
                        if (!bonusSaldos[participantId].bonusAdmin) {
                            bonusSaldos[participantId].bonusAdmin = [];
                        }
                        
                        bonusSaldos[participantId].bonusAdmin.push({
                            quantidade: quantidadeMB,
                            data: new Date().toISOString(),
                            admin: autorMensagem,
                            motivo: 'B√¥nus administrativo'
                        });

                        agendarSalvamento();

                        const quantidadeFormatada = quantidadeMB >= 1024 ? `${(quantidadeMB/1024).toFixed(2)}GB` : `${quantidadeMB}MB`;
                        const novoSaldo = bonusSaldos[participantId].saldo;
                        const novoSaldoFormatado = novoSaldo >= 1024 ? `${(novoSaldo/1024).toFixed(2)}GB` : `${novoSaldo}MB`;

                        console.log(`üéÅ ADMIN BONUS: ${autorMensagem} deu ${quantidadeFormatada} para ${numeroDestino}`);

                        // Notificar o usu√°rio que recebeu o b√¥nus
                        try {
                            await client.sendMessage(message.from, 
                                `üéÅ *B√îNUS ADMINISTRATIVO!*\n\n` +
                                `üíé @${numeroDestino}, recebeste *${quantidadeFormatada}* de b√¥nus!\n\n` +
                                `üë®‚Äçüíº *Ofertado por:* Administrador\n` +
                                `üí∞ *Novo saldo:* ${novoSaldoFormatado}\n\n` +
                                `${novoSaldo >= 1024 ? 'üöÄ *J√° podes sacar!* Use: *.sacar*' : 'üí° *Continua a acumular para sacar!*'}`, {
                                mentions: [participantId]
                            });
                        } catch (notificationError) {
                            console.error('‚ùå Erro ao enviar notifica√ß√£o de b√¥nus admin:', notificationError);
                        }

                        await message.reply(
                            `‚úÖ *B√îNUS ADMINISTRATIVO CONCEDIDO*\n\n` +
                            `üë§ Benefici√°rio: ${numeroDestino}\n` +
                            `üéÅ B√¥nus concedido: ${quantidadeFormatada}\n` +
                            `üí∞ Novo saldo: ${novoSaldoFormatado}\n` +
                            `üëë Concedido por: Administrador\n` +
                            `üìÖ Data: ${new Date().toLocaleString('pt-BR')}\n\n` +
                            `üí° *O usu√°rio foi notificado automaticamente*`
                        );
                        
                        return;
                    } catch (error) {
                        console.error('‚ùå Erro no comando .bonus:', error);
                        await message.reply(`‚ùå *ERRO INTERNO*\n\n‚ö†Ô∏è N√£o foi poss√≠vel conceder b√¥nus\n\nüìù Erro: ${error.message}`);
                        return;
                    }
                }
            }

            // === COMANDOS GOOGLE SHEETS ===
            if (comando === '.test_sheets') {
                console.log(`üß™ Testando Google Sheets...`);
                
                const resultado = await enviarParaGoogleSheets('TEST123', '99', '842223344', 'test_group', 'Teste Admin', 'TestUser');
                
                if (resultado.sucesso) {
                    await message.reply(`‚úÖ *Google Sheets funcionando!*\n\nüìä URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}\nüìù Row: ${resultado.row}\nüéâ Dados enviados com sucesso!`);
                } else {
                    await message.reply(`‚ùå *Google Sheets com problema!*\n\nüìä URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}\n‚ö†Ô∏è Erro: ${resultado.erro}\n\nüîß *Verifique:*\n‚Ä¢ Script publicado corretamente\n‚Ä¢ Permiss√µes do Google Sheets\n‚Ä¢ Internet funcionando`);
                }
                return;
            }

            if (comando === '.test_vision') {
                const visionStatus = ia.googleVisionEnabled;
                let resposta = `üîç *TESTE GOOGLE VISION*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                if (visionStatus) {
                    resposta += `‚úÖ **Google Vision: ATIVO**\n`;
                    resposta += `üîß **Configura√ß√£o:**\n`;
                    resposta += `   ‚Ä¢ Timeout: ${ia.googleVisionTimeout}ms\n`;
                    resposta += `   ‚Ä¢ Fallback: GPT-4 Vision\n\n`;
                    resposta += `üìù **Para testar:**\n`;
                    resposta += `1. Envie uma imagem de comprovante\n`;
                    resposta += `2. Verifique nos logs qual m√©todo foi usado\n`;
                    resposta += `3. Google Vision ser√° tentado primeiro\n`;
                    resposta += `4. GPT-4 Vision como fallback\n\n`;
                    resposta += `üìä **Vantagens do m√©todo h√≠brido:**\n`;
                    resposta += `   ‚úÖ Maior precis√£o OCR\n`;
                    resposta += `   ‚úÖ Menor custo\n`;
                    resposta += `   ‚úÖ Mais r√°pido\n`;
                    resposta += `   ‚úÖ Sistema redundante`;
                } else {
                    resposta += `‚ùå **Google Vision: DESABILITADO**\n\n`;
                    resposta += `üîß **Para ativar:**\n`;
                    resposta += `1. Configure GOOGLE_APPLICATION_CREDENTIALS no .env\n`;
                    resposta += `2. Ou configure GOOGLE_VISION_API_KEY\n`;
                    resposta += `3. Defina GOOGLE_VISION_ENABLED=true\n\n`;
                    resposta += `üß† **Atualmente usando:**\n`;
                    resposta += `   ‚Ä¢ GPT-4 Vision apenas\n`;
                    resposta += `   ‚Ä¢ Funciona normalmente\n`;
                    resposta += `   ‚Ä¢ Sem redund√¢ncia`;
                }
                
                await message.reply(resposta);
                return;
            }

            // === COMANDO PARA ADICIONAR COMANDOS CUSTOMIZADOS ===
            if (message.body.startsWith('.addcomando ')) {
                const comandoParsado = parsearComandoCustomizado(message.body);
                
                if (!comandoParsado) {
                    await message.reply(`‚ùå *Sintaxe incorreta!*\n\n‚úÖ *Sintaxe correta:*\n\`.addcomando NomeComando(Sua resposta aqui)\`\n\nüìù *Exemplo:*\n\`.addcomando horario(Funcionamos de 8h √†s 18h)\`\n\n‚ö†Ô∏è *Importante:*\n‚Ä¢ Nome sem espa√ßos\n‚Ä¢ Resposta entre par√™nteses\n‚Ä¢ Pode usar quebras de linha`);
                    return;
                }
                
                try {
                    await adicionarComandoCustomizado(
                        message.from,
                        comandoParsado.nome,
                        comandoParsado.resposta,
                        message.author || message.from
                    );
                    
                    await message.reply(`‚úÖ *Comando criado com sucesso!*\n\nüîß **Comando:** \`${comandoParsado.nome}\`\nüìù **Resposta:** ${comandoParsado.resposta.substring(0, 100)}${comandoParsado.resposta.length > 100 ? '...' : ''}\n\nüí° **Para usar:** Digite apenas \`${comandoParsado.nome}\``);
                    console.log(`‚úÖ Admin ${message.author || message.from} criou comando '${comandoParsado.nome}' no grupo ${message.from}`);
                } catch (error) {
                    await message.reply(`‚ùå **Erro ao criar comando**\n\nTente novamente ou contacte o desenvolvedor.`);
                    console.error('‚ùå Erro ao adicionar comando customizado:', error);
                }
                return;
            }

            // === COMANDO PARA LISTAR COMANDOS CUSTOMIZADOS ===
            if (comando === '.comandos') {
                const grupoId = message.from;
                const comandosGrupo = comandosCustomizados[grupoId];
                
                if (!comandosGrupo || Object.keys(comandosGrupo).length === 0) {
                    await message.reply('üìã *Nenhum comando customizado criado ainda*\n\nüí° **Para criar:** `.addcomando nome(resposta)`');
                    return;
                }
                
                let listaComandos = 'üìã *COMANDOS CUSTOMIZADOS*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n';
                
                Object.keys(comandosGrupo).forEach(nome => {
                    const cmd = comandosGrupo[nome];
                    const preview = cmd.resposta.length > 50 ? 
                        cmd.resposta.substring(0, 50) + '...' : 
                        cmd.resposta;
                    
                    listaComandos += `üîß **${nome}**\nüìù ${preview}\n\n`;
                });
                
                listaComandos += `üìä **Total:** ${Object.keys(comandosGrupo).length} comando(s)`;
                
                await message.reply(listaComandos);
                return;
            }

            // === COMANDO PARA REMOVER COMANDOS CUSTOMIZADOS ===
            if (message.body.startsWith('.delcomando ')) {
                const nomeComando = message.body.replace('.delcomando ', '').trim().toLowerCase();
                
                if (!nomeComando) {
                    await message.reply(`‚ùå *Nome do comando √© obrigat√≥rio!*\n\n‚úÖ *Sintaxe:* \`.delcomando nomecomando\`\n\nüìù *Para ver comandos:* \`.comandos\``);
                    return;
                }
                
                try {
                    const removido = await removerComandoCustomizado(message.from, nomeComando);
                    
                    if (removido) {
                        await message.reply(`‚úÖ *Comando removido!*\n\nüóëÔ∏è **Comando:** \`${nomeComando}\`\n\nüìù **Para ver restantes:** \`.comandos\``);
                        console.log(`‚úÖ Admin ${message.author || message.from} removeu comando '${nomeComando}' do grupo ${message.from}`);
                    } else {
                        await message.reply(`‚ùå *Comando n√£o encontrado!*\n\nüîç **Comando:** \`${nomeComando}\`\nüìù **Ver comandos:** \`.comandos\``);
                    }
                } catch (error) {
                    await message.reply(`‚ùå **Erro ao remover comando**\n\nTente novamente ou contacte o desenvolvedor.`);
                    console.error('‚ùå Erro ao remover comando customizado:', error);
                }
                return;
            }

            if (comando === '.test_grupo') {
                const grupoAtual = message.from;
                const configGrupo = getConfiguracaoGrupo(grupoAtual);
                
                if (!configGrupo) {
                    await message.reply('‚ùå Este grupo n√£o est√° configurado!');
                    return;
                }
                
                console.log(`üß™ Testando Google Sheets para grupo: ${configGrupo.nome}`);
                
                const resultado = await enviarParaGoogleSheets('TEST999', '88', '847777777', grupoAtual, configGrupo.nome, 'TestAdmin');
                
                if (resultado.sucesso) {
                    await message.reply(`‚úÖ *Teste enviado para ${configGrupo.nome}!*\n\nüìä Row: ${resultado.row}\nüîç O celular deste grupo deve processar em at√© 30 segundos.\n\nüì± *Grupo ID:* \`${grupoAtual}\``);
                } else {
                    await message.reply(`‚ùå *Erro no teste:* ${resultado.erro}`);
                }
                return;
            }

            if (comando === '.grupos_status') {
                let resposta = `üìä *STATUS DOS GRUPOS*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                for (const [grupoId, config] of Object.entries(CONFIGURACAO_GRUPOS)) {
                    const dadosGrupo = dadosParaTasker.filter(d => d.grupo_id === grupoId);
                    const hoje = dadosGrupo.filter(d => {
                        const dataItem = new Date(d.timestamp).toDateString();
                        return dataItem === new Date().toDateString();
                    });
                    
                    resposta += `üè¢ *${config.nome}*\n`;
                    resposta += `   üìà Total: ${dadosGrupo.length}\n`;
                    resposta += `   üìÖ Hoje: ${hoje.length}\n`;
                    resposta += `   üìä Sheets: ${dadosGrupo.filter(d => d.metodo === 'google_sheets').length}\n`;
                    resposta += `   üì± Backup: ${dadosGrupo.filter(d => d.metodo === 'whatsapp_backup').length}\n`;
                    resposta += `   üÜî ID: \`${grupoId}\`\n\n`;
                }
                
                await message.reply(resposta);
                return;
            }

            if (comando === '.sheets') {
                const dados = obterDadosTasker();
                const hoje = obterDadosTaskerHoje();
                const sheets = dados.filter(d => d.metodo === 'google_sheets').length;
                const whatsapp = dados.filter(d => d.metodo === 'whatsapp_backup').length;
                
                let resposta = `üìä *GOOGLE SHEETS STATUS*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                resposta += `üìà Total enviado: ${dados.length}\n`;
                resposta += `üìÖ Hoje: ${hoje.length}\n`;
                resposta += `üìä Via Google Sheets: ${sheets}\n`;
                resposta += `üì± Via WhatsApp: ${whatsapp}\n`;
                resposta += `üì± Fila atual: ${filaMensagens.length}\n\n`;
                
                if (dados.length > 0) {
                    resposta += `üìã *√öltimos 5 enviados:*\n`;
                    dados.slice(-5).forEach((item, index) => {
                        const metodo = item.metodo === 'google_sheets' ? 'üìä' : 'üì±';
                        resposta += `${index + 1}. ${metodo} ${item.dados} (${item.grupo})\n`;
                    });
                }
                
                await message.reply(resposta);
                return;
            }

            if (comando.startsWith('.clear_grupo ')) {
                const nomeGrupo = comando.replace('.clear_grupo ', '');
                const antes = dadosParaTasker.length;
                
                dadosParaTasker = dadosParaTasker.filter(d => !d.grupo.toLowerCase().includes(nomeGrupo.toLowerCase()));
                
                const removidos = antes - dadosParaTasker.length;
                await message.reply(`üóëÔ∏è *${removidos} registros do grupo "${nomeGrupo}" removidos!*`);
                return;
            }

            if (comando === '.clear_sheets') {
                dadosParaTasker = [];
                await message.reply('üóëÔ∏è *Dados do Google Sheets limpos!*');
                return;
            }

            // === COMANDOS TASKER - SISTEMA DE PACOTES ===
            
            // DEBUG: Verificar status do sistema de pacotes
            if (comando === '.debug_pacotes') {
                let resposta = `üîß *DEBUG SISTEMA PACOTES*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                resposta += `üîå SISTEMA_PACOTES_ENABLED: ${process.env.SISTEMA_PACOTES_ENABLED}\n`;
                resposta += `üì¶ sistemaPacotes: ${sistemaPacotes ? 'INICIALIZADO' : 'NULL'}\n`;
                resposta += `üë§ isAdminQualquer: ${isAdminQualquer}\n`;
                resposta += `üìù Comando original: "${message.body}"\n`;
                resposta += `üÜî Grupo ID: ${message.from}\n`;
                
                if (sistemaPacotes) {
                    resposta += `\n‚úÖ Sistema de Pacotes est√° ATIVO e funcionando!`;
                } else {
                    resposta += `\n‚ùå Sistema de Pacotes est√° DESABILITADO ou falhou ao inicializar!`;
                }
                
                await message.reply(resposta);
                return;
            }
            
            if (comando === '.pacotes_tasker') {
                const dadosPacotes = obterDadosPacotesTasker();
                
                if (dadosPacotes.length === 0) {
                    await message.reply(`üì¶ *DADOS TASKER - PACOTES*\n\n‚ùå Nenhum cliente com pacote ativo para o Tasker.`);
                    return;
                }
                
                let resposta = `üì¶ *DADOS TASKER - PACOTES* (${dadosPacotes.length})\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                dadosPacotes.forEach((cliente, index) => {
                    const proximaRenovacao = new Date(cliente.proximaRenovacao);
                    resposta += `${index + 1}. **${cliente.numero}**\n`;
                    resposta += `   üìã Ref: ${cliente.referenciaOriginal}\n`;
                    resposta += `   üì¶ Tipo: ${cliente.tipoPacote}\n`;
                    resposta += `   üìÖ Dias restantes: ${cliente.diasRestantes}\n`;
                    resposta += `   ‚è∞ Pr√≥xima: ${proximaRenovacao.toLocaleString('pt-BR')}\n\n`;
                });
                
                resposta += `üí° *O Tasker pode acessar estes dados via fun√ß√£o do bot para processar renova√ß√µes automaticamente.*`;
                
                await message.reply(resposta);
                return;
            }
            
            if (comando === '.renovacoes_tasker') {
                const renovacoesPendentes = obterRenovacoesPendentesTasker();
                
                if (renovacoesPendentes.length === 0) {
                    await message.reply(`üîÑ *RENOVA√á√ïES TASKER*\n\n‚úÖ Nenhuma renova√ß√£o pendente nas pr√≥ximas 6 horas.`);
                    return;
                }
                
                let resposta = `üîÑ *RENOVA√á√ïES TASKER* (${renovacoesPendentes.length})\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                renovacoesPendentes.forEach((cliente, index) => {
                    const proximaRenovacao = new Date(cliente.proximaRenovacao);
                    
                    resposta += `${index + 1}. **${cliente.numero}**\n`;
                    resposta += `   üìã Ref: ${cliente.referenciaOriginal}\n`;
                    resposta += `   üì¶ Tipo: ${cliente.tipoPacote}\n`;
                    resposta += `   üìÖ Dias restantes: ${cliente.diasRestantes}\n`;
                    resposta += `   ‚è∞ Pr√≥xima renova√ß√£o: ${proximaRenovacao.toLocaleString('pt-BR')}\n\n`;
                });
                
                resposta += `üí° *Hor√°rios j√° calculados com 2h de antecipa√ß√£o em rela√ß√£o ao dia anterior.*`;
                
                await message.reply(resposta);
                return;
            }

            // === COMANDOS DO SISTEMA DE COMPRAS ===
            
            if (comando === '.compras_stats') {
                if (!sistemaCompras) {
                    await message.reply('‚ùå Sistema de compras n√£o est√° ativo!');
                    return;
                }
                
                const estatisticas = await sistemaCompras.obterEstatisticas();
                
                let resposta = `üõí *ESTAT√çSTICAS DE COMPRAS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                resposta += `üìä Total de compradores: ${estatisticas.totalCompradores}\n`;
                resposta += `üìÖ Compradores hoje: ${estatisticas.compradoresHoje}\n`;
                resposta += `‚è≥ Compras pendentes: ${estatisticas.comprasPendentes}\n`;
                resposta += `üíæ Total de megas hoje: ${estatisticas.totalMegasHoje >= 1024 ? (estatisticas.totalMegasHoje/1024).toFixed(1) + ' GB' : estatisticas.totalMegasHoje + ' MB'}\n\n`;
                
                if (estatisticas.ranking.length > 0) {
                    resposta += `üèÜ *TOP 5 RANKING HOJE:*\n`;
                    estatisticas.ranking.slice(0, 5).forEach((cliente, index) => {
                        const megasFormatados = cliente.megasHoje >= 1024 ? `${(cliente.megasHoje/1024).toFixed(1)} GB` : `${cliente.megasHoje} MB`;
                        resposta += `${index + 1}¬∫ ${cliente.numero} - ${megasFormatados} (${cliente.comprasHoje}x)\n`;
                    });
                }
                
                await message.reply(resposta);
                return;
            }
            
            if (comando === '.ranking') {
                if (!sistemaCompras) {
                    await message.reply('‚ùå Sistema de compras n√£o est√° ativo!');
                    return;
                }
                
                const estatisticas = await sistemaCompras.obterEstatisticas();
                
                if (estatisticas.ranking.length === 0) {
                    await message.reply('üèÜ *RANKING DI√ÅRIO*\n\n‚ùå Nenhuma compra registrada hoje.');
                    return;
                }
                
                let resposta = `üèÜ *RANKING DI√ÅRIO DE COMPRAS*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                estatisticas.ranking.forEach((cliente, index) => {
                    const megasFormatados = cliente.megasHoje >= 1024 ? `${(cliente.megasHoje/1024).toFixed(1)} GB` : `${cliente.megasHoje} MB`;
                    const emoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
                    resposta += `${emoji} **${index + 1}¬∫ lugar**\n`;
                    resposta += `   üì± ${cliente.numero}\n`;
                    resposta += `   üìä ${megasFormatados} (${cliente.comprasHoje} compras)\n\n`;
                });
                
                resposta += `üìÖ *Ranking atualizado automaticamente a cada compra confirmada!*`;
                
                await message.reply(resposta);
                return;
            }
            
            if (comando.startsWith('.comprador ')) {
                if (!sistemaCompras) {
                    await message.reply('‚ùå Sistema de compras n√£o est√° ativo!');
                    return;
                }
                
                const numero = comando.replace('.comprador ', '').trim();
                
                if (!/^\d{9}$/.test(numero)) {
                    await message.reply('‚ùå Use: *.comprador 849123456*');
                    return;
                }
                
                const cliente = sistemaCompras.historicoCompradores[numero];
                
                if (!cliente) {
                    await message.reply(`‚ùå Cliente *${numero}* n√£o encontrado no sistema de compras.`);
                    return;
                }
                
                const posicao = await sistemaCompras.obterPosicaoCliente(numero);
                const megasHojeFormatados = cliente.megasHoje >= 1024 ? `${(cliente.megasHoje/1024).toFixed(1)} GB` : `${cliente.megasHoje} MB`;
                const megasTotalFormatados = cliente.megasTotal >= 1024 ? `${(cliente.megasTotal/1024).toFixed(1)} GB` : `${cliente.megasTotal} MB`;
                
                let resposta = `üë§ *PERFIL DO COMPRADOR*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                resposta += `üì± **N√∫mero:** ${numero}\n`;
                resposta += `üèÜ **Posi√ß√£o hoje:** ${posicao.posicao}¬∫ lugar\n`;
                resposta += `üìä **Hoje:** ${megasHojeFormatados} (${cliente.comprasHoje} compras)\n`;
                resposta += `üíé **Total geral:** ${megasTotalFormatados} (${cliente.totalCompras} compras)\n`;
                resposta += `üìÖ **Primeira compra:** ${new Date(cliente.primeiraCompra).toLocaleDateString('pt-BR')}\n`;
                resposta += `‚è∞ **√öltima compra:** ${new Date(cliente.ultimaCompra).toLocaleDateString('pt-BR')}\n`;
                
                await message.reply(resposta);
                return;
            }

            // === NOVOS COMANDOS PARA DETEC√á√ÉO DE GRUPOS ===
            if (comando === '.grupos') {
                try {
                    let resposta = `üìã *GRUPOS DETECTADOS*\n‚ö† NB: V√°lido apenas para Vodacom‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                    
                    const chats = await client.getChats();
                    const grupos = chats.filter(chat => chat.isGroup);
                    
                    resposta += `üìä Total de grupos: ${grupos.length}\n\n`;
                    
                    for (const grupo of grupos) {
                        const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(grupo.id._serialized);
                        const status = isMonitorado ? '‚úÖ' : '‚ùå';
                        
                        resposta += `${status} *${grupo.name}*\n`;
                        resposta += `   üÜî \`${grupo.id._serialized}\`\n`;
                        resposta += `   üë• ${grupo.participants.length} membros\n\n`;
                    }
                    
                    resposta += `\nüîß *Para adicionar grupo:*\nCopie ID e adicione em CONFIGURACAO_GRUPOS`;
                    
                    await message.reply(resposta);
                    
                    console.log(`\nüìã COMANDO .grupos executado - ${grupos.length} grupos encontrados`);
                    grupos.forEach(grupo => {
                        const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(grupo.id._serialized);
                        console.log(`${isMonitorado ? '‚úÖ' : '‚ùå'} ${grupo.name}: ${grupo.id._serialized}`);
                    });
                    
                } catch (error) {
                    console.error('‚ùå Erro ao listar grupos:', error);
                    await message.reply('‚ùå Erro ao obter lista de grupos');
                }
                return;
            }

            if (comando === '.grupo_atual') {
                if (!message.from.endsWith('@g.us')) {
                    await message.reply('‚ùå Use este comando em um grupo!');
                    return;
                }
                
                await logGrupoInfo(message.from, 'COMANDO .grupo_atual');
                
                const configGrupo = getConfiguracaoGrupo(message.from);
                const status = configGrupo ? '‚úÖ CONFIGURADO' : '‚ùå N√ÉO CONFIGURADO';
                
                await message.reply(
                    `üìã *INFORMA√á√ïES DESTE GRUPO*\n\n` +
                    `üÜî ID: \`${message.from}\`\n` +
                    `üìä Status: ${status}\n\n` +
                    `${configGrupo ? `üè¢ Nome: ${configGrupo.nome}` : 'üîß Precisa ser configurado'}\n\n` +
                    `üìù Verifique o console para detalhes completos`
                );
                return;
            }
        }

        // === COMANDOS DE REFER√äNCIA E B√îNUS (TODOS USU√ÅRIOS) ===
        if (message.type === 'chat' && message.body.startsWith('.')) {
            const comando = message.body.toLowerCase().trim();
            const remetente = message.author || message.from;

            // .meucodigo - Gerar/ver c√≥digo de refer√™ncia
            if (comando === '.meucodigo') {
                let codigo = null;
                
                // Verificar se j√° tem c√≥digo
                for (const [cod, dados] of Object.entries(codigosReferencia)) {
                    if (dados.dono === remetente) {
                        codigo = cod;
                        break;
                    }
                }
                
                // Se n√£o tem, criar novo
                if (!codigo) {
                    codigo = gerarCodigoReferencia(remetente);
                    codigosReferencia[codigo] = {
                        dono: remetente,
                        nome: message._data.notifyName || 'N/A',
                        criado: new Date().toISOString(),
                        ativo: true
                    };
                    agendarSalvamento();
                }
                
                await message.reply(
                    `üéÅ *SEU C√ìDIGO DE REFER√äNCIA*\n\n` +
                    `üìã C√≥digo: *${codigo}*\n\n` +
                    `üöÄ *Como usar:*\n` +
                    `‚Ä¢ Compartilhe este c√≥digo com amigos\n` +
                    `‚Ä¢ Quando eles fizerem primeira compra, voc√™ ganha 200MB\n` +
                    `‚Ä¢ A cada 5 compras deles, acumula 1GB\n` +
                    `‚Ä¢ Acumule 1GB+ para sacar b√¥nus\n\n` +
                    `üí° *Dica:* Diga aos amigos para usar *.convite ${codigo}* quando entrarem no grupo!`
                );
                return;
            }

            // .convite CODIGO - Registrar refer√™ncia
            if (comando.startsWith('.convite ')) {
                const codigo = comando.split(' ')[1]?.toUpperCase();
                
                if (!codigo) {
                    await message.reply('‚ùå Use: *.convite CODIGO*\nExemplo: *.convite AB12CD*');
                    return;
                }
                
                // Verificar se c√≥digo existe
                if (!codigosReferencia[codigo]) {
                    await message.reply(`‚ùå C√≥digo *${codigo}* n√£o encontrado!\n\nüí° Pe√ßa para quem te convidou verificar o c√≥digo com *.meucodigo*`);
                    return;
                }
                
                // Verificar se j√° tem refer√™ncia
                if (referenciasClientes[remetente]) {
                    await message.reply(`‚ö†Ô∏è Voc√™ j√° foi convidado por algu√©m!\n\nN√£o √© poss√≠vel usar outro c√≥digo de refer√™ncia.`);
                    return;
                }
                
                // Verificar se n√£o est√° tentando usar pr√≥prio c√≥digo
                if (codigosReferencia[codigo].dono === remetente) {
                    await message.reply('‚ùå N√£o podes usar teu pr√≥prio c√≥digo de refer√™ncia! üòÖ');
                    return;
                }

                // NOVA VALIDA√á√ÉO: Verificar se √© eleg√≠vel (entrou nos √∫ltimos 5 dias)
                if (!isElegivelParaCodigo(remetente, message.from)) {
                    await message.reply(
                        `‚è≥ *C√ìDIGO EXPIRADO PARA SEU PERFIL*\n\n` +
                        `‚ùå C√≥digos de refer√™ncia s√≥ funcionam para membros que entraram no grupo nos √∫ltimos 5 dias.\n\n` +
                        `ü§î *Por que isso acontece?*\n` +
                        `‚Ä¢ Sistema anti-abuse\n` +
                        `‚Ä¢ Incentiva convites genu√≠nos\n` +
                        `‚Ä¢ Protege economia do grupo\n\n` +
                        `üí° *Solu√ß√£o:* Voc√™ ainda pode gerar seu pr√≥prio c√≥digo com *.meucodigo* e convidar outros!`
                    );
                    return;
                }
                
                // Registrar refer√™ncia
                referenciasClientes[remetente] = {
                    convidadoPor: codigosReferencia[codigo].dono,
                    codigo: codigo,
                    dataRegistro: new Date().toISOString(),
                    comprasRealizadas: 0
                };
                
                agendarSalvamento();
                
                const convidadorId = codigosReferencia[codigo].dono;
                const nomeConvidador = codigosReferencia[codigo].nome;
                
                await client.sendMessage(message.from, 
                    `‚úÖ *C√ìDIGO APLICADO COM SUCESSO!*\n\n` +
                    `üéâ @${convidadorId.replace('@c.us', '')} te convidou - registrado!\n\n` +
                    `üíé *Benef√≠cios:*\n` +
                    `‚Ä¢ Nas tuas pr√≥ximas 5 compras, @${convidadorId.replace('@c.us', '')} ganha 200MB cada\n` +
                    `‚Ä¢ Tu recebes teus megas normalmente\n` +
                    `‚Ä¢ Ajudas um amigo a ganhar b√¥nus!\n\n` +
                    `üöÄ *Pr√≥ximo passo:* Faz tua primeira compra!`, {
                    mentions: [convidadorId]
                });
                return;
            }

            // .bonus - Ver saldo de b√¥nus
            if (comando === '.bonus' || comando === '.saldo') {
                const saldo = bonusSaldos[remetente];
                
                if (!saldo || saldo.saldo === 0) {
                    await message.reply(
                        `üí∞ *TEU SALDO DE B√îNUS*\n\n` +
                        `üéÅ Total acumulado: *0MB*\n` +
                        `üìä Refer√™ncias ativas: *0 pessoas*\n\n` +
                        `üöÄ *Como ganhar b√¥nus:*\n` +
                        `1. Gera teu c√≥digo com *.meucodigo*\n` +
                        `2. Convida amigos para o grupo\n` +
                        `3. Eles usam *.convite TEUCODIGO*\n` +
                        `4. A cada compra deles, ganhas 200MB\n` +
                        `5. Com 1GB+ podes sacar com *.sacar*`
                    );
                    return;
                }
                
                const saldoGB = (saldo.saldo / 1024).toFixed(2);
                const podeSacar = saldo.saldo >= 1024;
                const referenciasAtivas = Object.keys(saldo.detalhesReferencias || {}).length;
                
                let detalhes = '';
                if (saldo.detalhesReferencias) {
                    Object.entries(saldo.detalhesReferencias).forEach(([cliente, dados]) => {
                        const nome = dados.nome || 'Cliente';
                        detalhes += `‚Ä¢ ${nome}: ${dados.compras}/5 compras (${dados.bonusGanho}MB ganhos)\n`;
                    });
                }
                
                await message.reply(
                    `üí∞ *TEU SALDO DE B√îNUS*\n\n` +
                    `üéÅ Total acumulado: *${saldo.saldo}MB* (${saldoGB}GB)\n` +
                    `üìä Refer√™ncias ativas: *${referenciasAtivas} pessoas*\n` +
                    `üí° M√≠nimo para saque: 1GB (1024MB)\n\n` +
                    `${detalhes ? `üë• *Detalhes das refer√™ncias:*\n${detalhes}\n` : ''}` +
                    `${podeSacar ? 'üöÄ *Pronto para sacar!*\nUse: *.sacar 1GB 845123456*' : '‚è≥ Incentiva teus convidados a comprar!'}`
                );
                return;
            }

            // .sacar QUANTIDADE NUMERO - Solicitar saque
            if (comando.startsWith('.sacar ')) {
                const partes = comando.split(' ');
                if (partes.length < 3) {
                    await message.reply(
                        `‚ùå *FORMATO INCORRETO*\n\n` +
                        `‚úÖ Use: *.sacar QUANTIDADE NUMERO*\n\n` +
                        `üìã *Exemplos:*\n` +
                        `‚Ä¢ *.sacar 1GB 845123456*\n` +
                        `‚Ä¢ *.sacar 2048MB 847654321*\n` +
                        `‚Ä¢ *.sacar 1.5GB 843210987*`
                    );
                    return;
                }
                
                const quantidadeStr = partes[1].toUpperCase();
                const numeroDestino = partes[2];
                
                // Validar n√∫mero
                if (!/^8[0-9]{8}$/.test(numeroDestino)) {
                    await message.reply(`‚ùå N√∫mero inv√°lido: *${numeroDestino}*\n\n‚úÖ Use formato: 8XXXXXXXX`);
                    return;
                }
                
                // Converter quantidade para MB
                let quantidadeMB = 0;
                if (quantidadeStr.endsWith('GB')) {
                    const gb = parseFloat(quantidadeStr.replace('GB', ''));
                    quantidadeMB = gb * 1024;
                } else if (quantidadeStr.endsWith('MB')) {
                    quantidadeMB = parseInt(quantidadeStr.replace('MB', ''));
                } else {
                    await message.reply(`‚ùå Formato inv√°lido: *${quantidadeStr}*\n\n‚úÖ Use: 1GB, 1.5GB, 1024MB, etc.`);
                    return;
                }
                
                // Verificar saldo
                const saldo = bonusSaldos[remetente];
                if (!saldo || saldo.saldo < quantidadeMB) {
                    const saldoAtual = saldo ? saldo.saldo : 0;
                    await message.reply(
                        `‚ùå *SALDO INSUFICIENTE*\n\n` +
                        `üí∞ Teu saldo: ${saldoAtual}MB\n` +
                        `üéØ Solicitado: ${quantidadeMB}MB\n\n` +
                        `üí° Precisas de mais ${quantidadeMB - saldoAtual}MB\n` +
                        `üöÄ Convida mais amigos para ganhar b√¥nus!`
                    );
                    return;
                }
                
                // Verificar m√≠nimo
                if (quantidadeMB < 1024) {
                    await message.reply(`‚ùå Valor m√≠nimo para saque: *1GB (1024MB)*\n\nüéØ Solicitado: ${quantidadeMB}MB`);
                    return;
                }
                
                // Gerar refer√™ncia do pedido
                const agora = new Date();
                const referenciaSaque = `SAQ${agora.getFullYear().toString().slice(-2)}${String(agora.getMonth() + 1).padStart(2, '0')}${String(agora.getDate()).padStart(2, '0')}${String(Object.keys(pedidosSaque).length + 1).padStart(3, '0')}`;
                
                // Criar pedido
                const pedido = {
                    referencia: referenciaSaque,
                    cliente: remetente,
                    nomeCliente: message._data.notifyName || 'N/A',
                    quantidade: quantidadeMB,
                    numeroDestino: numeroDestino,
                    dataSolicitacao: agora.toISOString(),
                    status: 'pendente',
                    grupo: message.from
                };
                
                // Salvar pedido
                pedidosSaque[referenciaSaque] = pedido;
                
                // Debitar do saldo
                bonusSaldos[remetente].saldo -= quantidadeMB;
                bonusSaldos[remetente].historicoSaques = bonusSaldos[remetente].historicoSaques || [];
                bonusSaldos[remetente].historicoSaques.push({
                    referencia: referenciaSaque,
                    quantidade: quantidadeMB,
                    data: agora.toISOString()
                });
                
                agendarSalvamento();
                
                // Enviar para Tasker
                try {
                    await enviarParaTasker(referenciaSaque, quantidadeMB, numeroDestino, message.from, `SAQUE_BONUS_${message._data.notifyName || 'Cliente'}`);
                } catch (error) {
                    console.error('‚ùå Erro ao enviar saque para Tasker:', error);
                }
                
                const quantidadeFormatada = quantidadeMB >= 1024 ? `${(quantidadeMB/1024).toFixed(2)}GB` : `${quantidadeMB}MB`;
                const novoSaldo = bonusSaldos[remetente].saldo;
                
                await message.reply(
                    `‚úÖ *SOLICITA√á√ÉO DE SAQUE CRIADA*\n\n` +
                    `üë§ Cliente: ${message._data.notifyName || 'N/A'}\n` +
                    `üì± N√∫mero: ${numeroDestino}\n` +
                    `üíé Quantidade: ${quantidadeFormatada}\n` +
                    `üîñ Refer√™ncia: *${referenciaSaque}*\n` +
                    `‚è∞ Processamento: at√© 24h\n\n` +
                    `üí∞ *Novo saldo:* ${novoSaldo}MB\n\n` +
                    `‚úÖ Pedido enviado para processamento!\n` +
                    `üéâ Obrigado por usar nosso sistema de refer√™ncias!`
                );
                return;
            }
        }

        // === DETEC√á√ÉO DE GRUPOS N√ÉO CONFIGURADOS ===
        if (message.from.endsWith('@g.us') && !isGrupoMonitorado(message.from) && !message.fromMe) {
            if (!gruposLogados.has(message.from)) {
                await logGrupoInfo(message.from, 'MENSAGEM RECEBIDA');
                gruposLogados.add(message.from);
                
                // Limpar cache a cada 50 grupos para evitar memory leak
                if (gruposLogados.size > 50) {
                    gruposLogados.clear();
                }
            }
        }

        // === PROCESSAMENTO DE GRUPOS ===
        if (!message.from.endsWith('@g.us') || !isGrupoMonitorado(message.from)) {
            return;
        }

        const configGrupo = getConfiguracaoGrupo(message.from);
        if (!configGrupo || message.fromMe) {
            return;
        }

        // === DETEC√á√ÉO DE NOVOS MEMBROS (ALTERNATIVO) ===
        await detectarNovoMembro(message.from, autorMensagem, configGrupo);

        // === MODERA√á√ÉO ===
        if (message.type === 'chat') {
            // Verificar se √© um comando administrativo antes da modera√ß√£o
            const isComandoAdmin = message.body.startsWith('.') && (
                message.body.startsWith('.addcomando ') ||
                message.body.startsWith('.delcomando ') ||
                message.body.startsWith('.comandos') ||
                message.body.startsWith('.ia') ||
                message.body.startsWith('.stats') ||
                message.body.startsWith('.sheets') ||
                message.body.startsWith('.test_') ||
                message.body.startsWith('.grupos') ||
                message.body.startsWith('.clear_') ||
                message.body.startsWith('.ranking') ||
                message.body.startsWith('.inativos') ||
                message.body.startsWith('.semcompra') ||
                message.body.startsWith('.resetranking')
            );

            // Verificar se √© admin executando comando
            const autorModeracaoMsg = message.author || message.from;
            const isAdminExecutando = await isAdminGrupo(message.from, autorModeracaoMsg) || isAdministrador(autorModeracaoMsg);

            // Pular modera√ß√£o para comandos administrativos executados por admins
            if (!isComandoAdmin || !isAdminExecutando) {
                const analise = contemConteudoSuspeito(message.body);
                
                if (analise.suspeito) {
                    console.log(`üö® Conte√∫do suspeito detectado`);
                    await aplicarModeracao(message, "Link detectado");
                    return;
                }
            }
        }

        // === PROCESSAMENTO DE IMAGENS DESATIVADO ===
        if (message.type === 'image') {
            console.log(`üì∏ Imagem recebida - Processamento desativado`);

            await message.reply(
                '‚ùå Processamento de imagens desativado\n' +
                'üìÑ Solicitamos que o comprovante seja enviado em formato de texto.\n\n' +
                '‚ÑπÔ∏è Esta medida foi adotada para garantir que o sistema funcione de forma mais r√°pida, est√°vel e com menos falhas.'
            );
            return;
        }

        if (message.type !== 'chat') {
            return;
        }

        // Comandos de tabela e pagamento
        if (/tabela/i.test(message.body)) {
            await safeReply(message, client, configGrupo.tabela);
            return;
        }

        if (/pagamento/i.test(message.body)) {
            await safeReply(message, client, configGrupo.pagamento);
            return;
        }

        // === DETEC√á√ÉO DE PERGUNTA POR N√öMERO (N√ÉO-ADMIN) ===
        if (!isAdmin && detectarPerguntaPorNumero(message.body)) {
            console.log(`üì± Pergunta por n√∫mero detectada de n√£o-admin`);
            await message.reply(
                `üì± *Para solicitar n√∫mero ou suporte:*\n\n` +
                `üí≥ *Primeiro fa√ßa o pagamento:*\n\n` +
                `${configGrupo.pagamento}\n\n` +
                `üìù *Depois envie:*\n` +
                `‚Ä¢ Comprovante de pagamento\n` +
                `‚Ä¢ N√∫mero que vai receber os megas\n\n` +
                `ü§ñ *Sistema autom√°tico 24/7!*`
            );
            return;
        }

        // === VERIFICAR COMANDOS CUSTOMIZADOS ===
        const textoMensagem = message.body.trim().toLowerCase();
        const respostaComando = executarComandoCustomizado(message.from, textoMensagem);
        
        if (respostaComando) {
            await message.reply(respostaComando);
            console.log(`üéØ Comando customizado '${textoMensagem}' executado no grupo ${message.from}`);
            return;
        }

        // === MONITORAMENTO DE CONFIRMA√á√ïES DO BOT SECUND√ÅRIO ===
        if (sistemaCompras && message.body.includes('‚úÖ') && message.body.includes('Transa√ß√£o Conclu√≠da Com Sucesso')) {
            // Extrair refer√™ncia do padr√£o: "üîñ *Refer√™ncia:* CI22H8QJSDQ"
            const regexReferencia = /üîñ\s*\*?Refer√™ncia:\*?\s*([A-Za-z0-9._-]+)/i;
            const matchReferencia = message.body.match(regexReferencia);
            
            // Extrair n√∫mero do padr√£o: "üì± *N√∫mero:* 842362318"
            const regexNumero = /üì±\s*\*?N√∫mero:\*?\s*(\d{9})/i;
            const matchNumero = message.body.match(regexNumero);
            
            if (matchReferencia && matchNumero) {
                const referenciaConfirmada = matchReferencia[1]; // Manter case original
                const numeroConfirmado = matchNumero[1];
                console.log(`üõí CONFIRMA√á√ÉO BOT: Detectada transa√ß√£o conclu√≠da - Ref: ${referenciaConfirmada} | N√∫mero: ${numeroConfirmado}`);
                console.log(`üîç CONFIRMA√á√ÉO BOT: Tipo detectado: ${/emola|e-mola/i.test(message.body) ? 'EMOLA' : /mpesa|m-pesa/i.test(message.body) ? 'MPESA' : 'DESCONHECIDO'}`);
                
                // Processar confirma√ß√£o
                const resultadoConfirmacao = await sistemaCompras.processarConfirmacao(referenciaConfirmada, numeroConfirmado);
                
                if (resultadoConfirmacao) {
                    console.log(`‚úÖ COMPRAS: Confirma√ß√£o processada - ${resultadoConfirmacao.numero} | ${resultadoConfirmacao.megas}MB`);
                    
                    // Enviar mensagem de parabeniza√ß√£o com men√ß√£o clic√°vel
                    if (resultadoConfirmacao.mensagem && resultadoConfirmacao.contactId) {
                        try {
                            // Obter nome do contato para substituir o placeholder
                            const contact = await client.getContactById(resultadoConfirmacao.contactId);
                            
                            // Prioridade: nome salvo > pushname (nome do perfil) > name > n√∫mero
                            const nomeExibicao = contact.name || contact.pushname || contact.number;
                            const numeroLimpo = contact.id.user; // N√∫mero sem @ e sem +
                            
                            // Substituir placeholder pelo n√∫mero (formato correto para men√ß√µes click√°veis)
                            const mensagemFinal = resultadoConfirmacao.mensagem.replace('@NOME_PLACEHOLDER', `@${numeroLimpo}`);
                            
                            // Enviar com men√ß√£o clic√°vel
                            await client.sendMessage(message.from, mensagemFinal, { 
                                mentions: [resultadoConfirmacao.contactId] 
                            });
                        } catch (error) {
                            console.error('‚ùå Erro ao enviar parabeniza√ß√£o com men√ß√£o:', error);
                            // Fallback: enviar sem men√ß√£o clic√°vel
                            const mensagemFallback = resultadoConfirmacao.mensagem.replace('@NOME_PLACEHOLDER', `@${resultadoConfirmacao.numeroComprador}`);
                            await message.reply(mensagemFallback);
                        }
                    }
                } else {
                    console.log(`‚ö†Ô∏è COMPRAS: Confirma√ß√£o ${referenciaConfirmada} n√£o encontrada ou j√° processada`);
                }
                return;
            }
        }

        // === PROCESSAMENTO COM IA (L√ìGICA SIMPLES IGUAL AO BOT ATACADO) ===
        const remetente = message.author || message.from;
        const resultadoIA = await ia.processarMensagemBot(message.body, remetente, 'texto', configGrupo);
        
        if (resultadoIA.erro) {
            console.error(`‚ùå Erro na IA:`, resultadoIA.mensagem);
            return;
        }

        if (resultadoIA.sucesso) {
            
            if (resultadoIA.tipo === 'comprovante_recebido' || resultadoIA.tipo === 'comprovante_imagem_recebido') {
                const metodoInfo = resultadoIA.metodo ? ` (${resultadoIA.metodo})` : '';
                await message.reply(
                    `‚úÖ *Comprovante processado${metodoInfo}!*\n\n` +
                    `üí∞ Refer√™ncia: ${resultadoIA.referencia}\n` +
                    `üìä Megas: ${resultadoIA.megas}\n\n` +
                    `üì± *Envie UM n√∫mero que vai receber ${resultadoIA.megas}!*`
                );
                return;
                
            } else if (resultadoIA.tipo === 'numero_processado_com_aviso') {
                const dadosCompletos = resultadoIA.dadosCompletos;
                const [referencia, megas, numero] = dadosCompletos.split('|');
                const nomeContato = message._data.notifyName || 'N/A';
                const autorMensagem = message.author || 'Desconhecido';

                // PROCESSAR B√îNUS DE REFER√äNCIA
                const bonusInfo = await processarBonusCompra(remetente, megas);

                // VERIFICAR PAGAMENTO ANTES DE ENVIAR PARA PLANILHA
                // Usar o valor real do comprovante (n√£o o valor calculado dos megas)
                const valorComprovante = resultadoIA.valorComprovante || megas;
                const pagamentoConfirmado = await verificarPagamentoIndividual(referencia, valorComprovante);

                if (!pagamentoConfirmado) {
                    console.log(`‚ùå REVENDEDORES: Pagamento n√£o confirmado para texto - ${referencia} (${valorComprovante}MT)`);
                    await message.reply(
                        `‚è≥ *AGUARDANDO CONFIRMA√á√ÉO DO PAGAMENTO*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä Megas: ${megas} MB\n` +
                        `üì± N√∫mero: ${numero}\n` +
                        `üí≥ Valor: ${valorComprovante}MT\n\n` +
                        `üîç Aguardando confirma√ß√£o do pagamento no sistema...\n` +
                        `‚è∞ ${new Date().toLocaleString('pt-BR')}`
                    );
                    return;
                }

                console.log(`‚úÖ REVENDEDORES: Pagamento confirmado para texto! Processando...`);

                const resultadoEnvio = await enviarParaTasker(referencia, megas, numero, message.from, autorMensagem);

                // Verificar se √© pedido duplicado
                if (resultadoEnvio && resultadoEnvio.duplicado) {
                    const statusTexto = resultadoEnvio.status_existente === 'PROCESSADO' ? 'j√° foi processado' : 'est√° pendente na fila';
                    await message.reply(
                        `‚ö†Ô∏è *PEDIDO DUPLICADO DETECTADO*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä Megas: ${megas} MB\n` +
                        `üì± N√∫mero: ${numero}\n\n` +
                        `‚ùå Este pedido ${statusTexto}.\n` +
                        `üìù Status: ${resultadoEnvio.status_existente}\n\n` +
                        `‚è∞ ${new Date().toLocaleString('pt-BR')}`
                    );
                    return;
                }

                await registrarComprador(message.from, numero, nomeContato, megas);
                
                if (message.from === ENCAMINHAMENTO_CONFIG.grupoOrigem) {
                    const timestampMensagem = new Date().toLocaleString('pt-BR');
                    adicionarNaFila(dadosCompletos, autorMensagem, configGrupo.nome, timestampMensagem);
                }
                
                // Enviar mensagem normal + aviso da tabela
                await message.reply(
                    `‚úÖ *Pedido Recebido!*\n\n` +
                    `üí∞ Refer√™ncia: ${referencia}\n` +
                    `üìä Megas: ${megas} MB\n` +
                    `üì± N√∫mero: ${numero}\n\n` +
                    `${resultadoIA.avisoTabela}`
                );
                return;
                
            } else if (resultadoIA.tipo === 'numero_processado') {
                const dadosCompletos = resultadoIA.dadosCompletos;
                const [referencia, megas, numero] = dadosCompletos.split('|');
                const nomeContato = message._data.notifyName || 'N/A';
                const autorMensagem = message.author || 'Desconhecido';

                // PROCESSAR B√îNUS DE REFER√äNCIA
                const bonusInfo = await processarBonusCompra(remetente, megas);

                // VERIFICAR PAGAMENTO ANTES DE ENVIAR PARA PLANILHA
                // Usar o valor real do comprovante (n√£o o valor calculado dos megas)
                const valorComprovante = resultadoIA.valorComprovante || megas;
                const pagamentoConfirmado = await verificarPagamentoIndividual(referencia, valorComprovante);

                if (!pagamentoConfirmado) {
                    console.log(`‚ùå REVENDEDORES: Pagamento n√£o confirmado para texto - ${referencia} (${valorComprovante}MT)`);
                    await message.reply(
                        `‚è≥ *AGUARDANDO CONFIRMA√á√ÉO DO PAGAMENTO*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä Megas: ${megas} MB\n` +
                        `üì± N√∫mero: ${numero}\n` +
                        `üí≥ Valor: ${valorComprovante}MT\n\n` +
                        `üîç Aguardando confirma√ß√£o do pagamento no sistema...\n` +
                        `‚è∞ ${new Date().toLocaleString('pt-BR')}`
                    );
                    return;
                }

                console.log(`‚úÖ REVENDEDORES: Pagamento confirmado para texto! Processando...`);

                const resultadoEnvio = await enviarParaTasker(referencia, megas, numero, message.from, autorMensagem);

                // Verificar se √© pedido duplicado
                if (resultadoEnvio && resultadoEnvio.duplicado) {
                    const statusTexto = resultadoEnvio.status_existente === 'PROCESSADO' ? 'j√° foi processado' : 'est√° pendente na fila';
                    await message.reply(
                        `‚ö†Ô∏è *PEDIDO DUPLICADO DETECTADO*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä Megas: ${megas} MB\n` +
                        `üì± N√∫mero: ${numero}\n\n` +
                        `‚ùå Este pedido ${statusTexto}.\n` +
                        `üìù Status: ${resultadoEnvio.status_existente}\n\n` +
                        `‚è∞ ${new Date().toLocaleString('pt-BR')}`
                    );
                    return;
                }

                await registrarComprador(message.from, numero, nomeContato, megas);
                
                if (message.from === ENCAMINHAMENTO_CONFIG.grupoOrigem) {
                    const timestampMensagem = new Date().toLocaleString('pt-BR');
                    adicionarNaFila(dadosCompletos, autorMensagem, configGrupo.nome, timestampMensagem);
                }
                
                await message.reply(
                    `‚úÖ *Pedido Recebido!*\n\n` +
                    `üí∞ Refer√™ncia: ${referencia}\n` +
                    `üìä Megas: ${megas}\n` +
                    `üì± N√∫mero: ${numero}\n\n` +
                    `_‚è≥Processando... Aguarde enquanto o Sistema executa a transfer√™ncia_`
                );
                return;
            }
        }

        // === TRATAMENTO DE ERROS ===
        if (resultadoIA.tipo === 'numeros_sem_comprovante') {
            await message.reply(
                `üì± *N√∫mero detectado*\n\n` +
                `‚ùå N√£o encontrei seu comprovante.\n\n` +
                `üìù Envie primeiro o comprovante de pagamento.`
            );
            return;
        }

    } catch (error) {
        console.error('‚ùå Erro ao processar mensagem:', error);
    }
});

client.on('disconnected', (reason) => {
    console.log('‚ùå Bot desconectado:', reason);
});

// Capturar erros n√£o tratados
process.on('unhandledRejection', (reason, promise) => {
    if (reason.message && reason.message.includes('Execution context was destroyed')) {
        console.log('‚ö†Ô∏è Contexto do Puppeteer reiniciado, continuando...');
    } else {
        console.error('‚ùå Promise rejeitada:', reason);
    }
});

process.on('uncaughtException', (error) => {
    console.error('‚ùå Erro n√£o capturado:', error.message);
});

// === INICIALIZA√á√ÉO ===
(async function inicializar() {
    console.log('üöÄ Iniciando bot...');
    await carregarComandosCustomizados();
    console.log('üîß Comandos carregados, inicializando cliente WhatsApp...');
    
    try {
        client.initialize();
        console.log('üì± Cliente WhatsApp inicializado, aguardando conex√£o...');
    } catch (error) {
        console.error('‚ùå Erro ao inicializar cliente:', error);
    }
})();

// Salvar hist√≥rico a cada 5 minutos
setInterval(salvarHistorico, 5 * 60 * 1000);

// Limpar dados antigos do Tasker a cada hora
setInterval(() => {
    if (dadosParaTasker.length > 200) {
        dadosParaTasker = dadosParaTasker.slice(-100);
        console.log('üóëÔ∏è Dados antigos do Tasker removidos');
    }
}, 60 * 60 * 1000);

// === CACHE DESNECESS√ÅRIO REMOVIDO ===
// Arquivos .json dos pacotes removidos para otimiza√ß√£o
// Dados dispon√≠veis via comandos quando necess√°rio

// Limpar cache de grupos logados a cada 2 horas
setInterval(() => {
    gruposLogados.clear();
    console.log('üóëÔ∏è Cache de grupos detectados limpo');
}, 2 * 60 * 60 * 1000);

process.on('uncaughtException', (error) => {
    console.error('‚ùå Erro n√£o capturado:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promise rejeitada:', reason);
});

process.on('SIGINT', async () => {
    console.log('\nüíæ Salvando dados finais...');

    try {
        // Salvar apenas dados importantes (sem arquivos desnecess√°rios)
        await Promise.allSettled([
            salvarDadosReferencia(),
            salvarHistorico()
        ]);

        console.log('‚úÖ Dados salvos com sucesso!');
    } catch (error) {
        console.error('‚ùå Erro ao salvar:', error);
    }

    console.log('üß† IA: ATIVA');
    console.log('üìä Google Sheets: CONFIGURADO');
    console.log(`üîó URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}`);
    console.log('ü§ñ Bot Retalho - Funcionamento otimizado');
    console.log(ia.getStatus());
    process.exit(0);
});










