const axios = require('axios');
const cron = require('node-cron');

class SistemaRelatorios {
    constructor(client, googleSheetsConfig, pagamentosConfig) {
        this.client = client;
        this.configPedidos = googleSheetsConfig; // Script de pedidos
        this.configPagamentos = pagamentosConfig; // Script de pagamentos
        this.isRunning = false;

        // Configura√ß√£o de n√∫meros para relat√≥rios por grupo
        // AJUSTE ESTES N√öMEROS CONFORME NECESS√ÅRIO
        this.numerosRelatorio = {
            // 'GRUPO_ID': 'NUMERO_WHATSAPP',
            // Exemplo:
            // '258820749141-1441573529@g.us': '258847123456',
            // 'outro_grupo_id@g.us': '258841234567'
        };
    }

    /**
     * Configura n√∫mero de relat√≥rio para um grupo
     * @param {string} grupoId - ID do grupo
     * @param {string} numeroRelatorio - N√∫mero para receber relat√≥rios
     */
    configurarNumeroRelatorio(grupoId, numeroRelatorio) {
        this.numerosRelatorio[grupoId] = numeroRelatorio;
        console.log(`‚úÖ Configurado relat√≥rio do grupo ${grupoId} para ${numeroRelatorio}`);
    }

    /**
     * Remove configura√ß√£o de n√∫mero de relat√≥rio
     * @param {string} grupoId - ID do grupo
     */
    removerNumeroRelatorio(grupoId) {
        delete this.numerosRelatorio[grupoId];
        console.log(`‚ùå Removido relat√≥rio do grupo ${grupoId}`);
    }

    /**
     * Lista configura√ß√µes atuais
     */
    listarConfiguracoes() {
        console.log('üìã Configura√ß√µes de relat√≥rios:');
        for (const [grupoId, numero] of Object.entries(this.numerosRelatorio)) {
            console.log(`  ${grupoId} ‚Üí ${numero}`);
        }
    }

    /**
     * Calcula per√≠odo das √∫ltimas 24 horas
     */
    calcularPeriodo24h() {
        const agora = new Date();
        const fim = new Date(agora);
        const inicio = new Date(agora);
        inicio.setHours(inicio.getHours() - 24); // 24 horas atr√°s

        return {
            inicio: inicio.toISOString(),
            fim: fim.toISOString(),
            inicioFormatado: inicio.toLocaleDateString('pt-BR') + ' ' + inicio.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),
            fimFormatado: fim.toLocaleDateString('pt-BR') + ' ' + fim.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
        };
    }

    /**
     * Busca pedidos das √∫ltimas 24h para um grupo
     * @param {string} grupoId - ID do grupo
     * @param {Object} periodo - Per√≠odo de busca
     */
    async buscarPedidos24h(grupoId, periodo) {
        try {
            console.log(`üì¶ Buscando pedidos 24h para grupo: ${grupoId}`);

            // Tentar buscar com fun√ß√£o espec√≠fica (precisa implementar no Google Scripts)
            const response = await axios.post(this.configPedidos.scriptUrl, {
                action: "buscar_pedidos_24h",
                grupo_id: grupoId,
                data_inicio: periodo.inicio,
                data_fim: periodo.fim
            }, {
                timeout: this.configPedidos.timeout || 30000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.pedidos) {
                return {
                    pedidos: response.data.pedidos,
                    total: response.data.total || response.data.pedidos.length
                };
            }

        } catch (error) {
            console.log('‚ö†Ô∏è Fun√ß√£o espec√≠fica n√£o encontrada, usando fallback...');
        }

        // Fallback: usar fun√ß√£o existente (limita√ß√£o: s√≥ pega pendentes)
        try {
            const response = await axios.post(this.configPedidos.scriptUrl, {
                action: "buscar_pendentes",
                grupo_id: grupoId
            }, {
                timeout: this.configPedidos.timeout || 30000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.dados) {
                console.log('‚ö†Ô∏è Usando dados pendentes como aproxima√ß√£o (implementar busca 24h no Google Scripts)');
                return {
                    pedidos: response.data.dados,
                    total: response.data.total || response.data.dados.length,
                    fallback: true
                };
            }

        } catch (fallbackError) {
            console.error('‚ùå Erro ao buscar pedidos:', fallbackError.message);
        }

        return { pedidos: [], total: 0, error: true };
    }

    /**
     * Busca pagamentos das √∫ltimas 24h para um grupo
     * @param {string} grupoId - ID do grupo
     * @param {Object} periodo - Per√≠odo de busca
     */
    async buscarPagamentos24h(grupoId, periodo) {
        try {
            console.log(`üí∞ Buscando pagamentos 24h para grupo: ${grupoId}`);

            // Tentar buscar com fun√ß√£o espec√≠fica (precisa implementar no Google Scripts)
            const response = await axios.post(this.configPagamentos.scriptUrl, {
                action: "buscar_pagamentos_24h",
                grupo_id: grupoId,
                data_inicio: periodo.inicio,
                data_fim: periodo.fim
            }, {
                timeout: this.configPagamentos.timeout || 30000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.pagamentos) {
                return {
                    pagamentos: response.data.pagamentos,
                    total: response.data.total || response.data.pagamentos.length
                };
            }

        } catch (error) {
            console.log('‚ö†Ô∏è Fun√ß√£o espec√≠fica de pagamentos n√£o encontrada, usando fallback...');
        }

        // Fallback: usar fun√ß√£o existente (limita√ß√£o: s√≥ pega pendentes)
        try {
            const response = await axios.post(this.configPagamentos.scriptUrl, {
                action: "buscar_pendentes",
                grupo_id: grupoId
            }, {
                timeout: this.configPagamentos.timeout || 30000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.dados) {
                console.log('‚ö†Ô∏è Usando dados pendentes de pagamentos como aproxima√ß√£o');
                return {
                    pagamentos: response.data.dados,
                    total: response.data.total || response.data.dados.length,
                    fallback: true
                };
            }

        } catch (fallbackError) {
            console.error('‚ùå Erro ao buscar pagamentos:', fallbackError.message);
        }

        return { pagamentos: [], total: 0, error: true };
    }

    /**
     * Processa e cruza dados de pedidos e pagamentos
     * @param {Array} pedidos - Array de pedidos no formato REF|MEGAS|NUMERO
     * @param {Array} pagamentos - Array de pagamentos no formato REF|VALOR|NUMERO
     */
    processarDadosCombinados(pedidos, pagamentos) {
        const resultado = {
            totalPedidos: pedidos.length,
            totalGigas: 0,
            pagamentosConfirmados: 0,
            totalArrecadado: 0,
            pedidosPendentes: 0,
            valorPendente: 0,
            detalhes: []
        };

        // Criar mapa de pagamentos por refer√™ncia
        const mapPagamentos = new Map();
        pagamentos.forEach(pagamento => {
            try {
                const partes = pagamento.split('|');
                if (partes.length >= 3) {
                    const referencia = partes[0];
                    const valor = parseFloat(partes[1]) || 0;
                    mapPagamentos.set(referencia, valor);
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Erro ao processar pagamento:', pagamento);
            }
        });

        // Processar pedidos e cruzar com pagamentos
        pedidos.forEach(pedido => {
            try {
                const partes = pedido.split('|');
                if (partes.length >= 3) {
                    const referencia = partes[0];
                    const megas = parseInt(partes[1]) || 0;
                    const numero = partes[2];

                    // Converter megas para gigas
                    const gigas = megas / 1024;
                    resultado.totalGigas += gigas;

                    // Verificar se tem pagamento
                    const valorPagamento = mapPagamentos.get(referencia);

                    if (valorPagamento) {
                        resultado.pagamentosConfirmados++;
                        resultado.totalArrecadado += valorPagamento;
                    } else {
                        resultado.pedidosPendentes++;
                        // Estimar valor pendente (ajustar conforme sua l√≥gica)
                        const valorEstimado = this.calcularValorPorMegas(megas);
                        resultado.valorPendente += valorEstimado;
                    }

                    resultado.detalhes.push({
                        referencia,
                        megas,
                        gigas: parseFloat(gigas.toFixed(2)),
                        numero,
                        pagamento: valorPagamento || 0,
                        status: valorPagamento ? 'PAGO' : 'PENDENTE'
                    });
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Erro ao processar pedido:', pedido);
            }
        });

        // Arredondar valores
        resultado.totalGigas = parseFloat(resultado.totalGigas.toFixed(2));
        resultado.totalArrecadado = Math.round(resultado.totalArrecadado);
        resultado.valorPendente = Math.round(resultado.valorPendente);

        return resultado;
    }

    /**
     * Calcula valor estimado por megas (ajustar conforme tabela de pre√ßos)
     */
    calcularValorPorMegas(megas) {
        // Tabela de pre√ßos estimada - AJUSTAR CONFORME SUA REALIDADE
        if (megas >= 10240) return Math.floor(megas / 8.5);   // 10GB+
        if (megas >= 5120) return Math.floor(megas / 8.2);    // 5GB+
        if (megas >= 2048) return Math.floor(megas / 8.0);    // 2GB+
        if (megas >= 1024) return Math.floor(megas / 7.5);    // 1GB+
        return Math.floor(megas / 7.0); // Padr√£o
    }

    /**
     * Gera texto do relat√≥rio
     * @param {Object} dados - Dados processados
     * @param {string} grupoNome - Nome do grupo
     * @param {Object} periodo - Per√≠odo do relat√≥rio
     */
    gerarTextoRelatorio(dados, grupoNome, periodo) {
        let texto = `üìä *RELAT√ìRIO 24H* - ${grupoNome}\n`;
        texto += `üìÖ Per√≠odo: ${periodo.inicioFormatado} - ${periodo.fimFormatado}\n`;
        texto += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        // Se√ß√£o Vendas
        texto += `üì¶ *VENDAS (√öltimas 24h):*\n`;
        if (dados.totalPedidos === 0) {
            texto += `‚ùå Nenhum pedido registrado\n\n`;
        } else {
            texto += `‚úÖ Pedidos realizados: ${dados.totalPedidos}\n`;
            texto += `üåê Total gigas vendidos: ${dados.totalGigas} GB\n\n`;
        }

        // Se√ß√£o Pagamentos
        texto += `üí∞ *PAGAMENTOS (√öltimas 24h):*\n`;
        if (dados.pagamentosConfirmados === 0) {
            texto += `‚ùå Nenhum pagamento confirmado\n`;
        } else {
            texto += `‚úÖ Pagamentos confirmados: ${dados.pagamentosConfirmados}\n`;
            texto += `üíµ Total recebido: ${dados.totalArrecadado.toLocaleString('pt-BR')} MT\n`;
        }

        if (dados.pedidosPendentes > 0) {
            texto += `‚è≥ Pendentes: ${dados.pedidosPendentes} pedidos (‚âà${dados.valorPendente.toLocaleString('pt-BR')} MT)\n`;
        }
        texto += `\n`;

        // Se√ß√£o Performance (s√≥ se houver dados)
        if (dados.totalPedidos > 0) {
            const taxaConversao = Math.round((dados.pagamentosConfirmados / dados.totalPedidos) * 100);
            const ticketMedio = dados.pagamentosConfirmados > 0 ? Math.round(dados.totalArrecadado / dados.pagamentosConfirmados) : 0;
            const gigasPorVenda = dados.totalPedidos > 0 ? (dados.totalGigas / dados.totalPedidos).toFixed(2) : 0;

            texto += `üìä *PERFORMANCE:*\n`;
            texto += `üìà Taxa convers√£o: ${taxaConversao}% (${dados.pagamentosConfirmados}/${dados.totalPedidos})\n`;

            if (ticketMedio > 0) {
                texto += `üí∏ Ticket m√©dio: ${ticketMedio.toLocaleString('pt-BR')} MT\n`;
            }

            texto += `üåê Gigas por venda: ${gigasPorVenda} GB\n\n`;
        }

        texto += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        texto += `ü§ñ Relat√≥rio autom√°tico - ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;

        return texto;
    }

    /**
     * Gera relat√≥rio para um grupo espec√≠fico
     * @param {string} grupoId - ID do grupo
     * @param {string} grupoNome - Nome do grupo
     */
    async gerarRelatorioGrupo(grupoId, grupoNome = 'Grupo') {
        try {
            console.log(`üìä Gerando relat√≥rio 24h para: ${grupoNome} (${grupoId})`);

            const periodo = this.calcularPeriodo24h();

            // Buscar dados das duas planilhas
            const [resultadoPedidos, resultadoPagamentos] = await Promise.all([
                this.buscarPedidos24h(grupoId, periodo),
                this.buscarPagamentos24h(grupoId, periodo)
            ]);

            // Processar dados combinados
            const dados = this.processarDadosCombinados(
                resultadoPedidos.pedidos,
                resultadoPagamentos.pagamentos
            );

            // Gerar texto do relat√≥rio
            const textoRelatorio = this.gerarTextoRelatorio(dados, grupoNome, periodo);

            // Verificar se tem n√∫mero configurado para este grupo
            const numeroRelatorio = this.numerosRelatorio[grupoId];

            if (!numeroRelatorio) {
                console.log(`‚ö†Ô∏è Nenhum n√∫mero configurado para relat√≥rios do grupo ${grupoNome}`);
                return false;
            }

            // Enviar relat√≥rio para n√∫mero privado
            await this.client.sendMessage(numeroRelatorio + '@c.us', textoRelatorio);

            console.log(`‚úÖ Relat√≥rio enviado para ${numeroRelatorio} (grupo: ${grupoNome})`);

            // Log com alertas se houver fallbacks
            if (resultadoPedidos.fallback || resultadoPagamentos.fallback) {
                console.log('‚ö†Ô∏è Relat√≥rio gerado com limita√ß√µes - implementar busca 24h no Google Scripts');
            }

            return true;

        } catch (error) {
            console.error(`‚ùå Erro ao gerar relat√≥rio para ${grupoNome}:`, error.message);
            return false;
        }
    }

    /**
     * Executa relat√≥rios para todos os grupos configurados
     */
    async executarTodosRelatorios() {
        if (this.isRunning) {
            console.log('‚ö†Ô∏è Relat√≥rios j√° est√£o sendo executados, pulando...');
            return;
        }

        this.isRunning = true;
        console.log('üöÄ Iniciando gera√ß√£o de relat√≥rios 24h...');

        try {
            const gruposConfiguratos = Object.keys(this.numerosRelatorio);

            if (gruposConfiguratos.length === 0) {
                console.log('‚ö†Ô∏è Nenhum grupo configurado para relat√≥rios');
                return;
            }

            console.log(`üìã Processando ${gruposConfiguratos.length} grupos configurados`);

            // Buscar informa√ß√µes dos grupos
            const chats = await this.client.getChats();
            const mapaGrupos = new Map();

            chats.filter(chat => chat.isGroup).forEach(grupo => {
                mapaGrupos.set(grupo.id._serialized, grupo.name || 'Grupo sem nome');
            });

            let sucessos = 0;
            let falhas = 0;

            for (const grupoId of gruposConfiguratos) {
                try {
                    const nomeGrupo = mapaGrupos.get(grupoId) || 'Grupo Desconhecido';

                    await this.gerarRelatorioGrupo(grupoId, nomeGrupo);
                    sucessos++;

                    // Pausa entre relat√≥rios
                    await new Promise(resolve => setTimeout(resolve, 3000));

                } catch (error) {
                    console.error(`‚ùå Falha no grupo ${grupoId}:`, error.message);
                    falhas++;
                }
            }

            console.log(`‚úÖ Relat√≥rios conclu√≠dos! Sucessos: ${sucessos}, Falhas: ${falhas}`);

        } catch (error) {
            console.error('‚ùå Erro geral nos relat√≥rios:', error.message);
        } finally {
            this.isRunning = false;
        }
    }

    /**
     * Configura agendamento di√°rio √†s 22h
     */
    iniciarAgendamento() {
        console.log('‚è∞ Configurando agendamento de relat√≥rios √†s 22:00...');

        const job = cron.schedule('0 22 * * *', async () => {
            console.log('üïô Executando relat√≥rios agendados (22:00)...');
            await this.executarTodosRelatorios();
        }, {
            scheduled: false,
            timezone: "Africa/Maputo"
        });

        job.start();

        console.log('‚úÖ Agendamento configurado! Relat√≥rios √†s 22:00 (Maputo)');
        console.log(`üì± Grupos configurados: ${Object.keys(this.numerosRelatorio).length}`);

        return job;
    }

    /**
     * Teste manual de relat√≥rio
     * @param {string} grupoId - ID do grupo (opcional)
     */
    async testarRelatorio(grupoId = null) {
        console.log('üß™ Testando sistema de relat√≥rios...');

        if (grupoId) {
            const chats = await this.client.getChats();
            const grupo = chats.find(chat => chat.id._serialized === grupoId);
            const nomeGrupo = grupo ? grupo.name : 'Grupo de Teste';

            await this.gerarRelatorioGrupo(grupoId, nomeGrupo);
        } else {
            await this.executarTodosRelatorios();
        }
    }
}

module.exports = SistemaRelatorios;